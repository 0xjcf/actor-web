Great, I’ll research how real-world JavaScript/TypeScript actor system libraries—such as Akka.js, Theater.js, Caf.js, and others—implement mailbox processing, supervision, and event-driven triggers. I’ll prioritize cross-environment compatibility (web workers, clients, SSR, embedded), and evaluate architectural alternatives to timer-based polling.

I'll report back with implementation patterns, relevant examples, and a synthesis of recommended practices.


# Actor-System Message Processing: From Timer Loops to a Pure Actor Model

## Timer-Based Loops vs. Event-Driven Mailboxes

Using `setTimeout(..., 0)` for each message creates a pseudo-event loop that can be inefficient and deviates from pure actor model principles. In a pure actor model, actors process one message at a time *on demand*, rather than polling continuously. Timer loops introduce overhead (scheduling a new task for every message) and can lead to complexity in managing flags or race conditions. Best practices in JavaScript/TypeScript favor **event-driven processing** over continuous timer polling:

* **Leverage the JS Event Loop:** Instead of an explicit loop, schedule message handling as tasks in the existing event loop. For example, Node.js provides `setImmediate` or `process.nextTick` to execute a callback **asynchronously without delay**, and in browsers a common pattern is using `Promise.resolve().then(...)` or `MessageChannel`. In fact, a minimal actor send can be implemented by scheduling the actor’s behavior on the next tick (microtask or macrotask). As one article notes, “essentially what we want is `setTimeout()` with no delay” – using `setImmediate` if available, or `setTimeout(..., 0)` as a fallback. Many frameworks abstract this: for example, **Nact** uses a polyfill that tries `setImmediate`, `postMessage`, or `MessageChannel` for the fastest scheduling, and only falls back to `setTimeout(…, 0)` if needed. The goal is to enqueue message processing in the event loop, avoiding a busy waiting loop.

* **Process Messages on Demand:** An idle actor should only start processing when a new message arrives. In your current code, `startMessageProcessingLoop()` kicks off a loop when a message is enqueued. A more *event-driven* approach is to trigger processing **only** when transitioning from idle to non-empty mailbox. For example, maintain a flag for “is processing.” On each `enqueue`, if the actor is not already processing, schedule the processor (e.g. via `queueMicrotask` or similar). Let the actor run through its mailbox until empty, then mark it idle. If new messages arrive after that, schedule again. This way, you don't chain endless `setTimeout` calls; you only schedule a new task when there was a true state change (empty→non-empty mailbox). This pattern avoids unnecessary timer overhead and is aligned with actor models where the actor *itself* controls message throughput.

* **Async Await / Generators:** Another option is to treat the mailbox as an async iterable. For instance, an actor could run an async loop like:

  ```ts
  while (running) {
    const nextMsg = mailbox.dequeue() ?? await mailbox.waitForMessage();
    // process nextMsg
  }
  ```

  Here `waitForMessage()` would return a Promise that resolves when a new message is available (if the mailbox was empty). This uses the async/await mechanism to **pause** the actor’s message loop when there’s nothing to do, and resume when a message arrives – no busy polling. The actor system can implement `waitForMessage` by, say, an `EventEmitter` that emits a signal on each enqueue. This pattern is similar to how **Erlang** processes block waiting for messages, except in JS we use a Promise to avoid blocking the single thread. It provides responsiveness without a constant timer tick.

* **Event Emitters or Observables:** Instead of checking `mailbox.isEmpty()` in a loop, emit an event when a message is enqueued. The actor (or actor system) can listen to a `"message"` event. On receiving it, if the actor is idle, begin processing messages until the mailbox empties, then stop. Some implementations use this approach internally. For example, an actor’s mailbox can be an `EventEmitter` that triggers processing. This ensures **event-driven mailbox draining** – no timers, just events. One must be careful to process messages one at a time even if events fire quickly (e.g. disable or queue the event handler while one message is in progress).

In summary, **avoid continuous polling**. Instead, integrate with the JavaScript event loop: schedule asynchronous tasks for message delivery and use events or async-await to wake the actor when needed. This yields a design where *the arrival of a message* drives execution (reactive), rather than a loop constantly checking for work.

## Making the ActorSystem an Actor (State Machine)

Transforming `ActorSystemImpl` itself into an actor (or state machine) means the actor system participates in the same paradigm it orchestrates. In practice, actor frameworks often have a **root actor (guardian)** that supervises all others. The actor system can be modeled as this guardian actor:

* **State Machine for ActorSystem:** You can represent the ActorSystem as an XState statechart or similar state machine, with states like `"running"`, `"stopping"`, etc. For example, an `actorSystemMachine` might have an initial *idle* state that on a `START` event transitions to *running*. In the *running* state it could spawn child actors (on demand or on specific events) and listen for child termination or errors. This aligns with treating the system as the top-level actor. The state machine can handle events such as **actor spawn requests**, **actor termination notifications**, or **system shutdown signals**. In XState, the actor system machine could use the `spawn()` API to create child actors (each child being either an XState machine actor or a wrapper around your custom actor behavior). By doing so, the ActorSystem (as a parent machine) naturally supervises those children: if a child actor stops or crashes, the parent machine can define transitions or actions to restart it or clean up.

* **Supervision Strategies:** Designing the ActorSystem as an actor means you can implement supervision logic similar to Erlang/OTP’s supervisors. For each child actor, decide a policy: on failure, should the ActorSystem (parent) restart the actor, escalate the error, or terminate children? This can be encoded in the state machine or in the actor system logic. For instance, if using XState, a child machine error could send an event to the parent (via `onError` or invoking a callback service) and the parent can decide to spawn a new actor (restart) or move to a failure state. In a custom implementation, the ActorSystem actor might wrap each actor’s processing in a try/catch and emit a special message like `"CHILD_CRASHED"` with details, which the ActorSystem handles by applying a strategy (e.g. restart that actor, or escalate).

* **“Who supervises the supervisor?”** In Erlang/OTP, there's typically a root supervisor (often the **“init”** process) that is not supervised by anyone else – if it fails, the whole system terminates. Similarly, if your ActorSystem actor is the top of the hierarchy, it's essentially the **root guardian**. It can supervise all user actors, but if *it* fails, there’s no higher actor to restart it. The usual approach is to make the ActorSystem actor extremely robust or minimal (it should ideally not fail unexpectedly). The Akka documentation notes that the top-level actor should only start subsystems and not contain complex logic – this “guardian” is the kernel of your supervision tree, so keep it simple. In practice, your ActorSystem actor would only perform management tasks (spawning actors, stopping actors, monitoring) and not heavy application logic, minimizing chances of failure. If it does encounter an unrecoverable error, typically the whole ActorSystem would shut down (similar to Akka’s coordinated shutdown on guardian termination). So the actor system is supervised by the runtime itself (if at all) – in Node or browser, that might simply mean an uncaught error logs out. The design implication is: **the ActorSystem/guardian should be designed never to crash from routine message handling**; treat it as the stable root.

* **Hierarchical Actor Tree:** By making the ActorSystem an actor, you naturally get a hierarchy where it is parent to all root-level actors. This is how Akka and others structure things: user actors are children of the system’s guardian. This hierarchy is beneficial for fault isolation (children crash without killing the whole app) and for structure. It also means the ActorSystem actor can implement messages like `CreateActor`, `StopActor`, etc., as internal events. For example, the system could handle a `CREATE` event by spawning a new actor (and maybe transitioning through some internal state if needed), or an `ACTOR_FAILED` event by applying a supervision decision. Using a state machine for this means you can model states like "restarting child" or "shutting down" explicitly if needed.

**Example:** You could define an XState machine for the ActorSystem such that in the *running* state it responds to events like `{ type: 'SPAWN', actorDef }` by spawning a child actor (using `xstate.spawn` or invoking a service), and maybe an event like `{ type: 'CRASH', actorId, error }` which the system sends to itself when a child fails. The transition for `'CRASH'` could decide to either send a `RESTART` event to spawn a replacement or to escalate (transition to a state that stops all actors). This way, the ActorSystem’s behavior is itself event-driven and stateful, rather than a loop checking flags. This follows the idea that **the system orchestrator is itself an actor**, making the architecture more uniform.

## Event-Driven Mailbox Processing Patterns

Making mailbox processing event-driven is key to a responsive actor system. Here are patterns to consider for **triggering message handling without busy-waiting**:

* **Mailbox with Internal Signaling:** Modify your `BoundedMailbox` to have a mechanism to notify when a message is enqueued. For example, it could have a `this.onMessageAvailable` callback or an EventEmitter. When `enqueue` adds a message to an empty mailbox, it triggers a notification. The ActorSystem (or the actor itself) listening to that notification can then immediately schedule processing of that mailbox. This way, an actor that was idle will promptly wake up. Once processing, the actor can drain all queued messages. If it empties the mailbox, it goes idle and waits for the next signal. This pattern avoids polling `mailbox.isEmpty()` in a loop – instead the mailbox *pushes* a signal when there's work.

* **Integrate with Statecharts (if using XState):** The XState model processes events synchronously by default, which is different from the actor model where a mailbox queues events until the actor is ready. A solution, as seen in Huan’s **`mailbox`** library (built on XState), is to wrap a state machine in a parent machine that controls event dispatch. The child statechart processes one event at a time, and the parent (mailbox) holds incoming messages and only feeds the next one when the actor is “idle”. Concretely, they use an `idle` state that, on entry, triggers an action to dequeue the next message (if any) and send it to the child machine. When the child finishes processing an event and returns to idle, the mailbox actor automatically takes the next message. This design is fully event-driven: the arrival of a new event *and* the completion of processing the current event are what schedule the next step. It ensures no concurrent processing (one message at a time) while eliminating manual loops. The **key principle** is *decoupling receiving a message from processing it* – receive (enqueue) can be instantaneous and asynchronous, and processing is done when the actor is free.

* **Use the JavaScript Job Queue:** In a single-threaded JS environment, you cannot truly "block" waiting for a message, but you can simulate the actor idle behavior by relinquishing control until a new message comes. Using `await` as discussed or simply ending the processing function when done achieves this. For example, your `processActorMessages` function could be refactored: instead of a loop with `setTimeout`, have it process one message and return. After processing a message, if you detect the mailbox is non-empty, *schedule another task* (this is effectively what you do with `setTimeout(…,0)` today, but you could use a more optimal approach). If the mailbox *is* empty, don't schedule anything; just mark the actor idle. The next `enqueue` operation would then trigger a new task to process. This is similar to how DOM event handlers work in the browser: an event comes in, handler runs and finishes, and it waits for the next event. Here the mailbox acts as the event source.

* **Avoiding Race Conditions:** When using events or signals, be mindful of races like: if a message arrives exactly as the actor finishes processing the last message. In that case, the actor might have marked itself idle and then missed the signal. To prevent this, design the enqueue notification to be atomic with the state check. For instance, one approach is using an **atomic flag or CAS**: when enqueueing, if `isProcessing` is false (actor idle), set it true and fire off the processor; if `isProcessing` is true, do nothing (since the actor is already busy or scheduled). The actor, when finishing its run and seeing an empty mailbox, sets `isProcessing` false. If a race condition added a message after it became empty but before it flipped the flag, you might miss processing. Solutions include re-checking the mailbox under a lock or using a slightly more complex concurrency control (though in JS single-thread, the race can only occur if messages arrive via e.g. another event loop tick in between). Another simpler strategy: always re-check the mailbox one last time after you think you're done (just in case a new message snuck in). If you find one, continue the loop.

* **No Busy-Wait or Polling:** The bottom line is to rely on notifications or scheduling – **never a setInterval or continuous check**. Busy-waiting not only wastes CPU, it also violates the actor model philosophy (actors react to incoming messages rather than constantly scanning for them). The event-driven approach ensures the actor sleeps when there’s no work, and wakes up promptly when a new message arrives. This also maps well to JS’s single-threaded nature: it allows other code (or other actors) to run when an actor has no messages, rather than one actor’s loop hogging the thread.

By adopting these patterns, you move closer to a **pure event-driven mailbox**. This improves efficiency and aligns with how real actor systems (and even JS frameworks) work. For example, the tiny actor library **TartJS** demonstrated that you can simply use the JS event loop as the actor’s scheduler – it didn’t even have an explicit mailbox queue; calling an actor function used `process.nextTick` to defer execution, letting the event loop naturally queue messages. In TartJS, if you wanted a custom policy (like delaying messages), you could wrap an actor with another actor that uses a timeout before forwarding the message. The takeaway is that JavaScript’s own event loop can serve as the message queue in many cases, so we should integrate with it rather than inventing busy loops.

## Supervision Patterns in TypeScript Actor Systems (OTP-like Behavior)

Building resilience (the “let it crash” philosophy) requires supervision strategies similar to Erlang/OTP’s. Several existing JS/TS actor frameworks have implemented ideas from OTP:

* **Hierarchy of Supervisors:** In an OTP-style system, every actor is supervised by its parent. If a child crashes (throws an uncaught error while processing a message), the parent gets to decide what to do (restart the child, stop it, escalate the error upward, etc.). You can implement this in TS by structuring actors in a tree and catching errors. For example, your ActorSystem as the root can catch exceptions from child actors’ message handlers (if you `await` or wrap their processing). On catch, emit a supervision event as mentioned. Define policies per actor or per parent type. For instance, you might attach a strategy object to each actor (like `actor.supervision = OneForOne({ restartDelay: ... })` or similar). The ActorSystem would consult this on failure.

* **Existing Implementations:** **Nact** provides a good model: when spawning an actor, you can provide an `onCrash` handler (a function that receives the error, the message that caused it, and actor context) and returns a decision like `Stop`, `Restart` (reset state), `Resume`, or `Escalate`. This is analogous to OTP’s strategies (one-for-one restart, etc.). Nact’s decisions even include `StopAll` or `ResetAll` which affect sibling actors, similar to one-for-all supervision in OTP. In practice, implementing this means on child crash, the parent (ActorSystem) will either:

  * *Stop* the child (no restart, just remove it),
  * *Restart* the child (perhaps by creating a new instance of that actor with initial state),
  * *Resume* (ignore the failure and continue – in JS that might be rare, since the exception would have unwound the call stack),
  * *StopAll/ResetAll* means affect all children (for a one-for-all strategy),
  * *Escalate* means the parent itself should treat it as its own failure (i.e., bubble up to grandparent). If the ActorSystem is root, escalate would effectively bring down the system (or require an outer handler).

  You can use these ideas by coding a supervisor function in ActorSystem: e.g., a mapping from actor path to a supervision policy, and logic in the ActorSystem’s error handler to apply it.

* **Akka.js and Others:** **Akka.js** (a Scala.js implementation of Akka for JS) likely mirrors Akka’s supervision: each actor’s lifecycle is managed by the system. While details aren’t heavily documented for Akka.js, one can infer it uses a mailbox per actor and the actor’s `receive` method is invoked for each message dequeued. If an exception escapes `receive`, the actor will be suspended and its supervisor (parent) notified. The supervisor can then decide to restart the actor (calling its `preStart` again), stop it, or escalate. In Akka (JVM), these strategies are declared per parent (e.g., `OneForOneStrategy` with directives like Restart or Stop). You could implement something similar by allowing an actor definition to specify a `supervisionStrategy`.

* **Comedy.js** (another Node.js actor framework) also supports supervision and metrics. Comedy, for instance, has a concept of *actor guardians* and can respawn actors. It treats the actor system as a container where you get a `rootActor` reference (the guardian) and always spawn children from it. Comedy’s documentation emphasizes not directly creating child actors outside the system (they even removed external child spawning in a breaking change), enforcing hierarchical creation. For fault tolerance, Comedy logs actor crashes and in some modes will restart actors automatically. They also implement an **event bus** for system-wide messages (which can be useful for monitoring actor life cycle events like crashes).

* **Supervisor Tree Example:** Consider having a top-level supervisor that manages different subsystems. For example, you might have an `ActorSystem` that on start spawns a **UserSupervisor** actor and a **TaskSupervisor** actor, etc., each of which then spawns actual worker actors. This is a common pattern (divide responsibility among top-level supervisors). Each supervisor can have a policy: if a worker crashes, maybe just restart that worker (`OneForOne`), but if a supervisor itself crashes (which could happen if, say, two children errors were unhandled and bubbled), then the ActorSystem might decide to shut everything down (since a top-level supervisor failing is serious). This way, you isolate failures to the smallest scope. For **“who supervises the supervisor”**: the ActorSystem (guardian) supervises the top-level supervisors. The guardian is typically configured with a strategy where if a top-level supervisor dies (perhaps after retries), the whole system is brought down *gracefully*. This mirrors how the **Akka guardian** works – it is essentially the application root: if it terminates, the `ActorSystem.terminate()` is triggered.

* **Emulating OTP’s one-for-all vs one-for-one:** If you want to replicate OTP’s supervisor behaviors, you can do so in TS. For one-for-all, the parent on one child failure would stop or restart *all* its children (we saw Nact has `StopAll`/`ResetAll` decisions). For one-for-one, just the failing child is affected. This could be a simple loop in your ActorSystem’s handler: on a crash event, check the strategy type and for each child actor under that supervisor, take the appropriate action (stop/restart). The **bootstrap problem** (who starts the top supervisor) is solved by the ActorSystem creating the first supervisor(s) at startup (usually in a known good state). That’s why the guardian is often hardcoded to start a set of initial actors and then mostly wait for messages.

* **Isolation and Addressing:** Ensure that when actors restart, they either get a new identity or you clear their state. OTP restarts often create a new process with the same address (if in the same supervisor slot). You can mimic that by retaining the actor’s address and instantiating a fresh actor instance behind it. This might involve re-initializing its mailbox, etc. Your ActorSystem as an actor can maintain a map of addresses to actor instances/behaviors. On restart, replace the instance but keep the address the same so others don’t need to change references. This can be complex in JS if the actor has closure state, but if you model actors as pure functions or state machines, reinitializing is straightforward.

**References in the JS ecosystem:** The supervision idea is less about specific language and more architecture. Libraries like **Proto.Actor for JS** (inspired by Orleans) also implement supervision and a root context. While each has different APIs, the consensus is that a *supervisor actor* (be it the ActorSystem or a dedicated supervisor) receives error/failure signals from children and applies a policy. By examining these, you can design your ActorSystem actor to play the same role. For instance, Nact’s approach to pass the failing `msg, err` to a user-defined function allows custom logic – you could incorporate a similar callback or event in your system for advanced users to override default behavior.

## Performance Implications of Processing Strategies

Different message processing strategies can impact performance and responsiveness:

* **Continuous `setTimeout(…,0)` Loop:** This approach ensures no single actor hogs the thread for too long (because each message is processed in a new event-loop tick), but it comes at a cost. Scheduling a large number of micro-tasks or timeouts can significantly degrade throughput. Each `setTimeout(…,0)` incurs a call into the browser or Node event loop scheduler. If an actor has 1000 messages in its mailbox, your current loop will schedule 1000 separate timer callbacks. The overhead can be non-trivial, and it can also intermix other ready events between actor messages (which might or might not be desired). The positive side is that after each message, other system events get a chance to run, preventing UI freeze in a browser or allowing I/O in Node. However, if message volumes are high, this overhead reduces overall throughput.

* **Batch Processing (no yielding until mailbox empty or time slice):** If an actor processes all pending messages in one go (one synchronous chain), it maximizes throughput by avoiding extra scheduling. However, this can **hog the event loop**, causing latency for other actors or tasks. For example, if one actor receives a flood of messages, it could block the thread processing them for a long time, delaying other actors’ messages or UI updates. A middle ground is to **batch process with yielding**: process, say, N messages or process for X milliseconds, then yield (schedule continuation via `setImmediate` or similar) to let the loop breathe. Some actor libraries implement this. In fact, the Nact scheduling code uses a `Deadline` of \~10ms by default – it will execute queued tasks until either the queue is empty or 10ms has elapsed, then yield. This prevents unbounded blocking while still reducing the scheduling overhead by handling multiple messages per tick. Such time-slicing can dramatically improve throughput while keeping the app responsive.

* **Event Emitters and Sync Handling:** If you use an EventEmitter to handle incoming messages (i.e., emit `'message'` and in the handler call the actor’s behavior immediately), you are doing a **synchronous callback** (within the same tick) as soon as a message is enqueued. This has almost zero overhead for scheduling – the fastest possible delivery – but it means the message is processed *immediately* in the emitter’s call stack. If messages arrive in a burst, the emitter will call the handler repeatedly in succession before returning to the event loop. This is effectively the same as batch processing without yield. It’s high-throughput but can starve other tasks. Also, if the actor’s behavior is computationally heavy, doing it all in the emitter callback might block longer than desired. Therefore, while event emitters make it easy to notify of new messages, you might still intentionally defer processing by one tick to allow ordering and throttling.

* **Promise/Async (Microtask) vs `setTimeout` (Macrotask):** Using `await` (Promise) to schedule the next message processing puts the continuation in the **microtask queue**, which runs **before** the next rendering or I/O tick. This means if you do `await Promise.resolve()` between messages, all queued microtasks (i.e., subsequent message handlers) will execute back-to-back before the browser repaints or Node processes other timers. This can actually cause starvation of the macrotask queue if not careful. On the other hand, `setTimeout(…,0)` schedules a macrotask, which will run in the next turn of the event loop, after I/O and rendering. Microtasks are often faster/lower overhead, but they risk starving the UI more easily because they can flood the microtask queue. Macrotasks yield control to the environment more clearly. There’s also `queueMicrotask()` which is similar to promise scheduling. **In Node**, `process.nextTick` behaves like a microtask (it runs immediately after the current operation, even before promise microtasks), which if used in a tight loop could block I/O events from progressing. The **takeaway** is to use these mechanisms judiciously: for most purposes, a macrotask (setImmediate or setTimeout 0) per message ensures fairness at the cost of some overhead, whereas a microtask per message is lower overhead but can reduce fairness. Many frameworks (like browsers’ `MessageChannel` or Node’s `setImmediate`) strike a balance by queueing tasks in a way that other events still interleave.

* **Backpressure and Overload:** If messages are produced faster than they can be consumed, any approach will eventually face trouble (memory growth, latency spikes). Your `BoundedMailbox` with an `OverflowStrategy` addresses this by dropping or back-pressuring senders. That’s good. Under heavy load, a timer-loop might actually start lagging the event loop significantly because each tick is queued. Comedy.js documentation notes that if an actor cannot keep up, its message queue grows and **event loop lag increases**, possibly leading to an out-of-memory crash. They introduced an option to *drop messages on overload* when event loop lag exceeds a threshold. This is something to consider for performance: instrument the event loop delay (in Node, one can measure lag; in browsers, use `performance.now()` differences). If you detect the actor is falling behind (e.g., its mailbox size keeps growing or the time between scheduled ticks is large), you might invoke an overflow strategy (drop or throttle incoming messages). This ties into performance because uncontrolled mailbox growth not only uses memory, it also means longer processing bursts when the actor finally handles them, which can harm responsiveness.

* **Multi-threading and Environments:** In web workers or Node worker threads, you could potentially dedicate a thread per actor or a thread per actor system to parallelize. However, pure actor model can also run in one thread with cooperatively scheduled tasks. If you aim for compatibility across browser (single thread) and Node (maybe multi-thread possible), designing with the single-thread event loop in mind is wise. For multi-core scaling (like running actors in separate processes or workers), the model shifts to message passing between threads, which introduces its own performance considerations (serialization cost, etc.) – beyond the scope of this question, but something to keep in mind if Actor-Web might support web workers in the future. For now, within one event loop, the strategies discussed focus on not stalling that loop.

**Summary of Strategy Trade-offs:** An **event-driven, on-demand loop** (trigger when needed, process to completion or with modest yielding) is ideal for maximizing efficiency. Using the environment’s scheduling primitives (microtasks/macrotasks) is generally better than manually rolling a `setInterval`. Each approach must balance throughput vs. fairness:

* *High-throughput, lower fairness:* Process many messages in one tick (possibly via microtasks or direct sync loop). Good for compute-bound scenarios, but can cause jank.
* *High fairness, lower throughput:* One message per tick (what you have now with `setTimeout(…,0)` after each). Responsive, but overhead is noticeable if messages are tiny and frequent.
* *Balanced:* Batch a few messages or up to a time limit, then yield. This is often ideal in Node and browser apps to keep things smooth. It’s essentially cooperative scheduling. The Nact approach with a 10ms deadline is one example; you could implement similar by noting timestamps or counting messages.

By removing the explicit timer loop and making the actor system **reactive to new messages**, you will naturally lean towards a more balanced approach. For instance, if an actor processes a burst of 100 messages synchronously and you fear it blocking too long, you can explicitly insert a `await Promise.resolve()` or `setTimeout(…,0)` after processing, say, 50 messages to yield. This kind of tuning can be guided by performance testing.

## Real-World Actor Model Implementations (JS) – Comparison

It’s insightful to look at how existing libraries handle these concerns:

* **Akka.js:** As a JavaScript adaptation of Akka, it follows the classic actor model. Each actor has a mailbox, and messages are processed FIFO. The actor’s `receive(msg)` method is called by the framework for each message dequeued. Akka.js likely uses a mixture of microtasks or its own scheduler (perhaps leveraging the underlying Scala.js environment). Supervision mirrors Akka – each actor can have a supervisor strategy (default is to restart child on failure). Akka’s design, being on the JVM originally, uses threads and an executor – on JS, Akka.js would use the single-thread event loop but mimic concurrency via asynchronous callbacks. The key takeaway from Akka.js is the **one message at a time** guarantee and the parent-child hierarchy. They ensure that if you send 3 messages quickly, the actor will process them one by one in order, likely by internally queueing them.

* **Comedy.js:** A Node.js actor framework focused on scalability. Comedy uses the concept of an actor system with a root actor (obtained via `actors().rootActor()`). Message sending is asynchronous (`actor.send(...)` returns immediately). Internally, Comedy can use Node’s event loop to queue messages. Notably, Comedy supports *clustering* (multi-process or multi-host actors) and *threaded actors*, which implies it offloads some actors to separate Node processes for parallelism. Within a single process, Comedy monitors event loop lag. The **drop on overload** feature (when event loop lag > 3s, start dropping messages) suggests Comedy processes messages back-to-back as long as they arrive, and if that backlog causes huge delay, it prefers dropping messages to crashing. This indicates Comedy’s default is closer to high-throughput (not yielding each message) – it lets the queue grow and works it off, but with a safeguard. For supervision, Comedy has actor lifecycle hooks (`initialize`, `destroy`) and will automatically respawn actors in some scenarios (they mention *Actor Respawning (Supervision)* in their docs). It likely follows a one-for-one approach by default – if a child actor crashes (throws in a handler), the error can bubble to the parent which can spawn a replacement. Users can configure this via parameters, though the docs don’t dive deeply into custom policies.

* **Nact:** A modern TS implementation that is explicitly inspired by Akka/Erlang. Nact enforces one actor system per Node process and uses message passing with Promises. The internal scheduling (as we saw) uses a macro-task queue optimized for environment. They treat actor message handling as promises (the actor function can be async, and Nact will await it). Under the hood, Nact’s macro-task runner likely batches messages and yields appropriately. It’s also noteworthy that Nact integrates event sourcing/persistence, which implies the mailbox processing might interact with I/O (hence the need to not block the event loop). Nact’s supervision is very OTP-like with `onCrash` policies, so it’s a great reference for how to do this in TS. If an actor crashes, by default it stops, but you can provide a function to reset state or escalate. Because Nact uses Promises, an actor crash might show up as a rejected promise; Nact catches that and transforms it into a supervision event.

* **tartJS:** This minimal library demonstrates a radically simple approach: **no dedicated mailbox data structure at all** – sending a message is just calling a function that `process.nextTick` the actor behavior. This means messages naturally queue in Node’s internal nextTick queue. It relies on the fact that if you call `actorRef(msg)` multiple times, each call schedules the behavior for later, maintaining order. tartJS thereby *trusts the platform’s event loop* entirely. This is an existence proof that you can have actors without timers and without custom queues. However, tartJS doesn’t provide features like backpressure or supervision out of the box – it expects you to build those patterns by composing actors (for example, their suggestion of making a mailbox actor that delays messages by 1 second using `setTimeout` as a behavior). Performance-wise, tartJS is extremely lightweight (just function calls and nextTick). It’s efficient unless an actor does heavy work, in which case you’d need to manually insert delays if needed.

* **Huan’s `mailbox` (XState addon):** We discussed this above in the context of event-driven design. It’s a specific solution for XState machines to behave like actors with mailboxes. It uses a parent-child statechart pattern to queue events. Performance-wise, it introduces a slight overhead by wrapping a machine, but ensures no event storms overwhelm the actor – events queue up if the actor is busy. If you plan to use XState v5’s `createActor` API, note that XState’s built-in actors already queue events (they are closer to actor model than XState v4, which was sync). But if using XState v5, you might get away without building your own mailbox, since XState v5 actors process events in order and you can `.send` to them asynchronously. Still, understanding Huan’s approach is useful for implementing your own mailbox if needed, especially if you want to strictly control processing order and timing.

Finally, consider environment compatibility: Node vs browser. In Node, you have more options like `setImmediate` and can measure event loop delays; in browsers you have `requestIdleCallback` which can be used to schedule low-priority work (maybe not directly useful for actor messages, but an option for background actors). The patterns we discussed aim to be **universal (SSR, Web, Workers, etc.)** – none rely on Node-only APIs except `setImmediate`. For a universal library, you might use a polyfill approach like Nact’s: try Node-specific APIs, fallback to `MessageChannel` for browsers (which is a trick to create a macrotask), and then to `setTimeout`. This ensures your ActorSystem runs consistently in all JS contexts.

In conclusion, by eliminating the explicit `setTimeout` loops and adopting an event-driven actor system, you align with the best practices seen in these libraries. You’ll get a design that is **cleaner (the ActorSystem orchestrates via messages/events, not manual loops)**, likely more efficient, and easier to reason about in terms of actor behavior (since each actor truly processes one message at a time, triggered by the system when available). Adopting proven patterns from Akka/Erlang in a JS-friendly way (promises, event loop tasks) will give your framework robustness and clarity. The end result should be an actor system that is location-transparent, supervisable, and performant – without any `setTimeout(...,0)` hackery needed in the main loop.

**Sources:**

* TartJS using `process.nextTick` and JS event loop instead of custom mailbox.
* Nact’s scheduling polyfill showing use of `setImmediate/postMessage` vs `setTimeout`.
* XState-based mailbox ensuring one-at-a-time processing with an idle state.
* Akka.js API indicating actor `receive` is called on mailbox dequeue.
* Comedy.js documentation on message queue growth and event loop lag.
* Akka docs on guardian (top-level actor) and best practices.
