Great! I’ll begin researching patterns and strategies to enable type-safe topic systems and proxy-based subscribe APIs over your Event Broker while adhering to your pure actor model constraints. I’ll focus on zero-runtime TypeScript approaches, DX improvements from frameworks like Akka and Orleans, and build-time-safe abstractions.

I’ll update you with findings and actionable design recommendations soon.


# Improving Event Broker Developer Experience in Actor-Web Framework

## Background: Direct vs Brokered Subscriptions in Actor-Web

In the current Actor-Web framework, developers have two ways to handle events between actors: a simple **direct subscription** for local events, and a more complex **Event Broker** for distributed pub/sub. The direct approach looks like typical event emitters – you call `subscribe(eventName, callback)` on a local actor and get events via that callback. In contrast, using the Event Broker requires explicit message passing: sending a `SUBSCRIBE` message to a special broker actor, handling incoming `TOPIC_EVENT` messages with switch statements, and sending `PUBLISH` messages for events. This discrepancy leads to **4× more code** and much more boilerplate when using the broker (distributed) approach versus the local approach. The goal is to achieve the benefits of the broker (location transparency, persistence, audit trails) **without** imposing so much complexity on developers.

**Pain Points Recap:** With the current Event Broker API, developers must manually manage topic strings, route messages by topic and event type with nested `switch` logic, and handle their own `UNSUBSCRIBE` cleanup. There is no compile-time check that a topic name or payload matches what the publisher sends. This verbosity and lack of type safety make the distributed pub/sub hard to adopt, even though it’s essential for scaling beyond a single page or process.

## Lessons from Other Actor Frameworks’ Pub/Sub APIs

Other actor-model and event-driven frameworks have faced similar challenges and devised **simpler APIs** for publish/subscribe that maintain location transparency:

* **Akka (JVM):** Akka’s actor system includes an **EventStream** that actors can use for pub/sub without hard-coding message protocols. In Akka *Typed*, an actor can subscribe to events of a certain class type by sending a one-line command to the system event stream. For example, an actor can do: `context.system.eventStream ! Subscribe(adapter)` to listen for an event type, using a message adapter to convert the event into a message the actor handles. Publishing is similarly one-line (`system.eventStream ! Publish(new EventType(...))`), and Akka handles delivering the event to all subscribed actors (even allowing wildcards via class hierarchy). Notably, Akka’s approach requires minimal boilerplate: subscribe and publish are single calls, and subscribers are automatically removed on termination. The key insight is that Akka’s event bus is a built-in service of the actor system, offering **location transparency** (especially with Akka’s DistributedPubSub extension for clustering) while keeping the API high-level (no manual message routing in user code).

* **Orleans (Microsoft .NET):** Orleans uses a concept of **Streams** for pub/sub in a distributed grain (actor) network. It achieves strong typing by binding each stream to a specific data type (using generics) and allows implicit subscription via metadata. For instance, a grain class can be annotated with an attribute `[ImplicitStreamSubscription("MyStreamNamespace")]`, indicating that it should automatically receive events published to that topic/namespace. The Orleans runtime takes care of subscribing the grain to that stream behind the scenes when the grain activates. The developer then only needs to attach a handler for the stream events (implementing an interface or providing a delegate). Orleans streams thus hide the subscription plumbing; a grain can simply call `await stream.SubscribeAsync(OnNextAsync)` to start receiving events in a type-safe way. This design shows that **declarative subscriptions** (via attributes or configuration) can reduce boilerplate. Orleans also demonstrates **type safety** by binding each stream to a payload type `T` – if a stream is defined for `T = UserUpdatedEvent`, consumers and producers must use that type, catching mismatches at compile time.

* **Distributed Systems & Reactive Streams:** Outside the strict actor model, systems like **Kafka Streams** or libraries like **RxJS** tackle complexity with higher-level abstractions. Kafka Streams, for example, lets you define processing topologies in code rather than manually subscribing to topics, and it handles the underlying pub/sub mechanics internally. Similarly, RxJS uses Observables, where subscribers can declaratively filter and transform event streams. While these aren’t actor frameworks, the common theme is presenting a **declarative or fluent API** to handle events (e.g. `observable.filter(...).subscribe(handler)` in RxJS) instead of imperative subscribe/unsubscribe calls. This can inspire an API where the developer describes what to listen for and how to handle it, and the framework manages the rest. The trade-off is that such abstractions might hide the underlying message-passing, but they greatly improve developer experience by removing boilerplate.

**Takeaway:** Successful patterns from other frameworks include making pub/sub a first-class, always-available service of the runtime (like Akka’s EventStream or Orleans’ Streams), using strong typing (Akka’s use of event **classes** or Orleans’ generic stream types) to eliminate stringly-typed topics, and supporting declarative or one-line subscription APIs. These will guide improvements to Actor-Web’s Event Broker API.

## Compile-Time Type Safety for Topics and Events (Highest Priority)

One of the most effective ways to improve the Event Broker experience is to introduce **compile-time type safety** for the events being published and subscribed. Currently, topic names are strings (e.g. `"COUNTER_VALUE_CHANGED"`) and payloads are loosely defined, which means a typo in a topic or a mismatched payload type will only cause runtime issues. We can fix that by leveraging TypeScript’s powerful type system:

* **Typed Topic Definitions:** Define a TypeScript *mapping* of topic names to their payload types. For example, we might declare an interface or type like:

  ```ts
  interface EventTopics {
    "COUNTER_VALUE_CHANGED": { newCount: number };  
    "USER_PROFILE_UPDATED": { userId: string; changes: Partial<UserProfile> };  
    // ... other topics
  }
  ```

  This `EventTopics` type acts as the central source of truth for all allowed event topics and the shape of data each carries. With this in place, the subscribe and publish functions can be generically typed to enforce correctness.

* **Generic Subscribe/Publish Signatures:** Using the mapping above, we implement the Event Broker’s interface with generics:

  ```ts
  class EventBrokerClient {
      subscribe<K extends keyof EventTopics>(
          topic: K,
          handler: (payload: EventTopics[K]) => void
      ): SubscriptionHandle { … }
      publish<K extends keyof EventTopics>(
          topic: K,
          event: EventTopics[K]
      ): void { … }
  }
  ```

  Here, if a developer writes `eventBroker.subscribe("COUNTER_VALUE_CHANGED", handler)`, the TypeScript compiler knows that the handler must accept an object `{ newCount: number }` (and *only* that shape). If they try to subscribe to a nonexistent topic or handle it with the wrong payload type, it will be a compile-time error. Likewise, publishing an event will be type-checked. This completely eliminates whole classes of bugs (e.g. misspelled topic names or incorrect payload structure) **before** the code ever runs.

* **No More Stringly-Typed Events:** By using string literal types or a union of specific topic constants, we avoid arbitrary strings. Each topic becomes akin to an enum value from the perspective of the compiler. Some implementations even generate a **union type** for topics automatically. For instance, using a template literal or const assertions can ensure `"user.profile.*"` patterns are recognized, but more on wildcards below.

* **Wildcard and Hierarchical Topics:** Supporting wildcard topics (e.g. `"user.profile.*"`) in a type-safe way is challenging but feasible. One approach is to define hierarchical keys in the `EventTopics` mapping, such as grouping under a namespace:

  ```ts
  interface EventTopics {
    "user.profile.updated": UserProfile;
    "user.profile.deleted": { userId: string };
    "order.*": OrderEvent; // generic payload for any order-related event
  }
  ```

  If a wildcard subscribe (`"order.*"`) should receive multiple event types, the handler might use a union type for the payload or a discriminated union to differentiate events. Alternatively, we could decide that wildcard subscriptions are for broad handling (with perhaps a less strict type like `any` or a base interface) while encouraging specific topic subscriptions for full type safety. This is a design choice: **maximize type safety on explicit topics**, and handle wildcards either with unions or by treating them as a special-case (possibly requiring the handler to do runtime checks). The key is that for the majority of cases (specific topics), developers get strong guarantees, and even for patterns, the set of possible events can be known and typed.

* **Existing Patterns and Libraries:** The approach of mapping event names to types is well-established in TypeScript. For example, Node.js’s EventEmitter can be wrapped to be type-safe. A published solution uses a generic wrapper where `on<TEvent extends keyof Events>` ties the event name to a tuple of argument types. In our context, since each event carries a single payload object, we map to that object’s type instead of a tuple of args. Similarly, the **“strict-event-emitter”** pattern uses mapped types to constrain `emit` and `on` calls. An example from a blog post demonstrates defining `TypedEventEmitter<TEvents>` such that `.on("event-2", handler)` expects the handler signature to match the event’s defined tuple of arguments. If you remove or change an event’s payload definition, all subscribers and publishers for that event highlight type errors, making refactoring much safer. This technique will allow our Event Broker API to be **self-documenting** (IDE auto-complete can list available topics) and reliable.

* **Type-Safe Unsubscribe:** Another benefit of a typed system is improving the unsubscribe process. In the current pattern, developers manually track subscription IDs or topics to unsubscribe. With a typed system, we can make unsubscribing less error-prone. For example, one approach is to have `eventBroker.subscribe()` return a handle that encapsulates the topic information, so calling `unsubscribe` with that handle is always correct. A pattern shown in a TypeScript pub-sub gist is to return the actual handler function as the subscription token, then require the same topic and handler for unsubscription – the compiler will error if you try to unsubscribe a handler from the wrong topic. For instance:

  ```ts
  const handler = broker.subscribe('error', (e: ErrorEvent) => { /* ... */ });
  broker.unsubscribe('error', handler);        // OK, types match  
  broker.unsubscribe('warn', handler);         // ❌ Compile error, wrong topic  
  ```

  This ensures you can’t mistakenly unsubscribe the wrong listener. Alternatively, we could return an object with an `unsubscribe()` method bound to the correct topic internally, allowing simply `handle.unsubscribe()` without needing to pass parameters at all. Regardless of the approach, enforcing the correspondence between subscribe and unsubscribe calls via types will simplify cleanup logic for developers and prevent memory leaks from forgotten unsubscriptions.

In summary, introducing a **type-safe topic system** in Actor-Web will drastically reduce errors and remove a lot of boilerplate (no more manual casting of message payloads or string matching). Developers will use a clean API like:

```ts
// Type-checked subscribe
const sub = eventBroker.subscribe("USER_PROFILE_UPDATED", (payload) => {
  console.log(payload.userId, payload.changes);
});
// Type-checked publish
eventBroker.publish("USER_PROFILE_UPDATED", { userId: "123", changes: { name: "Alice" } });
```

The framework internals can still use the generic `TOPIC_EVENT` messages, but at the edges (the developer-facing API) everything is **strongly typed**. This bridges the gap between the dynamic nature of actor messaging and the static guarantees of TypeScript, giving us the best of both worlds.

## Proxy or Wrapper API for Event Broker (Hiding the Message Plumbing)

To make the Event Broker easier to use, we can introduce a **proxy object or wrapper API** that exposes simple methods like `subscribe()` and `publish()`, internally translating them to the requisite actor messages. This proxy would act as a friendly façade over the EventBroker actor, so developers don’t need to interact with raw messages. Here’s how this could work and the considerations involved:

* **Local Proxy Instance:** When an actor declares a dependency on the Event Broker (e.g. in the `dependencies` map of `defineComponentBehavior`), instead of getting a raw actor reference, it could receive a local **EventBrokerClient** object. This client would have the methods `subscribe(topic, callback)`, `publish(topic, event)`, etc., implemented to communicate with the actual broker actor. For example, `eventBrokerClient.subscribe("ORDER_CREATED", handler)` would perform two main actions: (1) send a `SUBSCRIBE` message under the hood to the broker actor, and (2) register the provided `handler` function locally so that incoming events on that topic trigger the callback. This resembles how Orleans allows clients to call grain methods or how Akka provides the `eventStream` interface – it feels like a normal method call, but it’s actually message passing behind the scenes.

* **Message Interception for Callbacks:** Once subscribed, how do events get from the broker actor back to the callback in your component? One approach is to leverage the actor’s own message loop. The actor will still receive `TOPIC_EVENT` messages from the broker, but we can **intercept or handle them inside the proxy** before they reach the user’s switch logic. For instance, the framework could augment the actor’s behavior such that any `TOPIC_EVENT` message is first checked against a map of subscriptions (populated by `subscribe()` calls). If a matching topic is found, the framework invokes the associated callback function with the event payload, instead of (or in addition to) forwarding that message to the developer’s `onMessage` handler. This way, the developer can write a straightforward callback to handle the event, exactly as they would in the local case, and **never have to write a `switch(topic)` or unwrap the payload manually**.

* **Maintaining Actor Model Semantics:** Using a callback in an actor context raises the question of actor model “purity”. We must ensure that calling the callback doesn’t violate single-threaded access to actor state. If the callback simply uses the actor’s provided API (like calling `machine.send()` as in the local example), this is essentially sending a new message or invoking a state machine transition, which is safe. The callback should not directly mutate shared state; in our framework, state is anyway encapsulated in the actor’s state machine (XState context). We can document that the callback is meant for triggering follow-up messages or state updates, not for long-running computations. It effectively acts like a mini message handler for that specific event type. Since our actors are built on XState, an alternative implementation could be to use XState’s built-in mechanisms – for example, XState actors can spawn observables or callbacks that send events back to the machine. We might integrate the Event Broker subscription as an **invocation** that sends events to the state machine when messages arrive, thereby maintaining the model of “input event triggers state transition” in a more declarative way. The key is that from the developer’s perspective, they wrote a callback or provided a handler function, and the framework takes care of wiring it up to the broker messages.

* **Asynchronous Subscription Setup:** The `subscribe()` method may need to be `async` (returning a Promise or using `await`) as shown in the target developer experience snippet. This is because subscribing might involve network communication with a broker on another node, or at least an acknowledgment that the subscription is in place. In practice, we can choose to either (a) make subscribe fire-and-forget (return an unsubscribe handle immediately, and handle the actual SUBSCRIBE message asynchronously in the background), or (b) return a Promise that resolves when the broker confirms the subscription. Approach (a) gives a simpler API (no `await` needed), but approach (b) might be safer for ensuring the subscription definitely happened before proceeding. A compromise is to allow both: the subscribe could return a handle (with an `unsubscribe()` method) and also have an `await`-able promise if the developer wants to ensure completion. This is an implementation detail, but worth considering for DX (Developer Experience). Either way, providing an *unsubscribe mechanism* is crucial. The proxy can keep track of the topic and callback, and offer `unsubscribe()` that sends the `UNSUBSCRIBE` message to the broker and removes the local callback mapping. This would mirror how the subscription was set up, but again with a single call from the developer side.

* **Error Handling & Edge Cases:** If the Event Broker is unavailable or returns an error (for example, if subscribing to a topic fails due to a permission issue or similar), the high-level API should surface that to the developer in a friendly way (perhaps by rejecting the promise from `subscribe()` or emitting an error event). Additionally, if the actor itself is stopped or re-mounted, the framework should ideally auto-cleanup any subscriptions (much like Akka’s event stream removing terminated subscribers). The developer using the proxy wouldn’t need to manually send `UNSUBSCRIBE` on component unmount – the framework could detect actor termination and inform the broker. These considerations ensure that by hiding complexity, we don’t also hide necessary control or feedback. The goal is **reducing boilerplate**, not removing control; so the proxy might also allow advanced usage if needed (e.g., a way to get low-level access if absolutely required, though in normal use it wouldn’t be).

**Trade-offs:** Wrapping the message-passing in a proxy means developers rely on the framework’s abstraction rather than seeing the raw actor messages. This is generally positive for productivity, but it can sometimes make debugging harder if not transparent. We should document what the proxy is doing (perhaps in dev mode, a subscription could log that it’s sending a SUBSCRIBE to topic X). Another trade-off is that this approach introduces a bit of **“magic”** behind the scenes – it breaks the illusion that everything is just an actor receiving messages. However, as long as the proxy itself doesn’t maintain hidden state beyond the subscription callbacks, it’s really just sugar on top of the actor model, not a new paradigm. In essence, we are following the principle of the **Proxy Pattern**: provide a familiar interface (`subscribe`/`publish`) while delegating the work to the existing system (EventBroker actor). This pattern is feasible and commonly used in distributed systems (for example, Orleans generates proxy objects for grains so that calling grain methods remotely feels like local calls). By adopting it, Actor-Web can maintain full location transparency and message-driven underpinnings, but present a **greatly simplified API** to developers.

## Declarative Subscription Declarations (Annotations & Metadata)

Another avenue to improve usability is to allow developers to declare their event subscriptions *declaratively* (at component definition time) rather than imperatively setting them up in code. This approach can reduce boilerplate in the actor’s message handler and make the code more self-documenting. Let’s consider some possibilities and examples from other systems:

* **Decorators in TypeScript:** Since Actor-Web is written in TypeScript, we could leverage decorator syntax to mark certain methods of a component’s behavior as event handlers for specific topics. For example, one might write:

  ```ts
  @SubscribeTopic("COUNTER_VALUE_CHANGED")
  function onCounterChanged(eventPayload: { newCount: number }) {
    machine.send({ type: 'UPDATE_COUNT', newCount: eventPayload.newCount });
  }
  ```

  This hypothetical `@SubscribeTopic` decorator would serve as metadata indicating that when the component mounts, it should automatically subscribe to the `"COUNTER_VALUE_CHANGED"` topic, and any events for that topic should be routed to this method. Under the hood, the framework would read these metadata entries (via reflection or a compile-time transform) and perform the `SUBSCRIBE` calls on the Event Broker for each decorated method. The advantage is that the developer writes zero boilerplate in `onMessage` for these events – they simply declare “I want to listen to this topic” and provide the handler logic. This is analogous to how some frontend frameworks use annotations (e.g., Angular’s `@HostListener` or NestJS’s event handlers) to declaratively wire events.

* **Framework Lifecycle Hooks:** If adding decorators is too heavy or not desirable, we could also introduce a higher-level configuration in the behavior definition. For instance, when defining a component behavior, we might add a `subscriptions` field:

  ```ts
  defineComponentBehavior({
    dependencies: { eventBroker: 'actor://system/event-broker' },
    subscriptions: {
      "COUNTER_VALUE_CHANGED": ({ newCount }) => ({ type: 'UPDATE_COUNT', newCount })
    },
    onMessage: async ({ message, machine }) => { … }
  });
  ```

  In this design, the `subscriptions` object maps topic names to handler functions (which can directly send a message or perform an update). The framework would take this and effectively do the subscribe calls for you on mount, and handle routing of events to those functions. This is a more declarative style than manually coding it in the message handler, and it fits naturally in the component definition structure. It’s similar to how Redux (with sagas or observers) might declare interest in certain actions, or how XState can have actions that respond to events in a statechart.

* **Implicit Subscription via Naming Conventions:** Orleans’ **Implicit Stream Subscription** attribute is a compelling example of using metadata to avoid manual subscription calls. In Orleans, if a grain’s identity (ID) matches part of the stream key, the runtime auto-subscribes the grain. While our use-case is different (UI components likely aren’t identified by the data they want), the general idea is that some subscription intent is declared outside of the procedural code. We might not have a direct analog to Orleans’ attribute unless we imagine something like tagging a component class with the topics it cares about. However, since Actor-Web components are defined by behavior objects rather than classes, decorators (which require classes or methods) might need us to shift to class-based definitions or use a function wrapping technique.

* **Benefits of Declarative Approach:** The main benefit is **clarity and reduction of boilerplate**. A developer reading the component code can immediately see which topics it subscribes to (either by decorators or a `subscriptions` field), without wading through the `onMessage` logic. It separates the *what* (subscribe to X) from the *how* (handle X by doing Y). Additionally, the framework can optimize or manage those subscriptions globally – for example, if a component with a declarative subscription is not currently active, the framework could choose not to propagate those events to it at all, etc. It opens the door to potential performance tuning like auto-unsubscribe on unmount (since the framework knows exactly what was subscribed when the component was mounted).

* **Drawbacks and Complexity:** Implementing decorators or config-based subscriptions adds complexity to the framework’s initialization process. We’d need to ensure that before or during an actor’s activation, it registers all its topic subscriptions. In practice, this could hook into the same place we handle `MOUNT_COMPONENT`. For example, instead of the developer writing code on `MOUNT_COMPONENT` to subscribe, the framework’s component mount handler could check if the behavior has a `subscriptions` definition and execute those. Another consideration is tooling: decorators are still a stage-2 proposal in TypeScript (though widely used via experimental flag). Relying on them means opting into that experimental feature or using compile-time code generation. A more conservative approach is the explicit `subscriptions` object as shown, which doesn’t need any special language support.

In summary, a **declarative subscription pattern** could greatly clean up user code. Whether via TypeScript decorators, configuration in the behavior definition, or patterns like Orleans’ attributes, the idea is to move the subscription setup out of the business logic. Other actor frameworks show this is viable: Orleans uses attributes to auto-subscribe grains to streams, and Akka’s Typed actors often use *setup* logic or context methods to subscribe right when the actor starts (which is similar in spirit). Actor-Web can adopt a hybrid of these: e.g., provide a utility to declare subscriptions at define-time which the framework then effects at run-time. This would complement the Proxy approach – in fact, the declarative layer could be built on top of the proxy under the hood (i.e., the framework calls `eventBrokerClient.subscribe(topic, handler)` for each declared subscription automatically). This again moves us closer to the ideal DX where a developer simply declares their interests and writes the handling logic, without writing repetitive wiring code.

## Unified Local & Distributed Event APIs (Hybrid Design)

A significant challenge is how to allow a **seamless transition** between local-only event subscriptions and distributed event broker subscriptions. In the current state, these are two entirely separate mechanisms (ActorEventBus for local vs EventBroker actor for distributed). The goal is to make an actor’s code oblivious to whether it’s communicating within one process or across many – i.e. to achieve **location transparency** for events in practice. Some patterns and ideas for a unified API:

* **Single Subscribe Interface:** Ideally, a component shouldn’t have to know which system it’s using. We could aim for a single `subscribe(eventName, handler)` method that “just works” whether the event is coming from a local actor or needs to be routed via the broker. How to achieve this? One idea is to **merge the ActorEventBus and EventBroker functionalities** into a unified service. For example, the ActorSystem could maintain an internal pub/sub service where any actor can publish an event and any interested actor (local or remote) can subscribe. The system would under the hood decide how to deliver that event – if publisher and subscriber are in the same process, maybe it shortcuts through the local bus; if not, it delegates to the broker mechanism. This could be implemented by having the Event Broker actor always running and integrated, but providing hooks for local short-circuits. In effect, every event could go through the broker, but the broker might recognize local targets and not serialize the message out of process if unnecessary.

* **Gradual Migration Path:** Providing a unified API means a developer can start with everything in one page (all actors local) using the subscribe calls, and later, if some actors move to a server or another thread, the **same code** continues to work. This was listed as a success criterion: “allow gradual migration from local to distributed patterns.” Concretely, this could mean that initially `dependencies.counterService.subscribe("COUNT_CHANGED", cb)` was a direct method on a local object. If we refactor `counterService` to be a remote actor (accessible only via messages), we would then use `eventBroker.subscribe("COUNT_CHANGED", cb)` to get updates. But if we unify them, perhaps the `counterService` itself could expose a subscribe method (even if remote). This is tricky without breaking the actor model, but one approach: if `counterService` is remote, its proxy could forward subscribe calls to the Event Broker on a topic named after that specific actor’s events. In other words, each actor type could have its own topic namespace for events it emits. The developer calls `remoteActor.subscribe("SomeEvent", handler)` and behind the scenes that might be translated to `eventBroker.subscribe("RemoteActorType:SomeEvent", handler)` with the remote actor publishing events to that topic. This way, the syntax remains identical whether `counterService` is local (then it could optimize by direct callback) or remote (then it goes through broker). This pattern is somewhat akin to Orleans streams where you might get a stream for a specific grain ID – here the “topic” could implicitly be tied to the actor instance.

* **Optional vs Mandatory Broker:** The question was raised whether the Event Broker should be a **required system service** rather than an optional one. Making it required (always present in the actor system) has the benefit that the framework can bake in assumptions about its availability. For instance, the unified `subscribe` interface can always funnel through the broker if needed. Many frameworks do include a messaging broker by default: Akka’s event stream is always there in an actor system; some cloud actor platforms have built-in pub/sub. If we treat Event Broker as fundamental, we can simplify configurations (no need to list it as a dependency explicitly in every component that wants it – maybe it’s just globally accessible or injected by default). It also means we can **automate certain behaviors** like auto-unsubscribe on actor termination, because the system knows about all subscriptions centrally. The trade-off is a slight increase in baseline resource usage (one broker actor always running) and potentially routing overhead for purely local interactions. However, if performance is a concern, we could allow an optimization mode where local subscriptions bypass the broker (while still using the same API). This might be done by detecting that the publisher actor is in the same process and linking the callback directly to the publisher’s event bus. In any case, the developer wouldn’t need to think about this – it would be an internal optimization.

* **Consistent Semantics:** Unifying the APIs also means reconciling semantics like **delivery guarantees**. If the local event bus currently delivers events synchronously (or in-order) vs the broker which may be async and possibly out-of-order (if distributed), the unified approach should clarify the expectations. We likely should default to the more robust semantics of the broker (as it covers distributed cases) – e.g., assume events are asynchronous and possibly out-of-order unless using additional ordering keys or sequence numbers (similar to how cloud Pub/Sub systems handle ordering). The user could be given tools to enforce ordering if needed, but the key is they don’t have to use a different API to get those features, it’s a configuration of the same API. For example, a unified subscribe might accept options like `{ ordered: true }` or the topic definitions could include whether ordering is needed, which the broker can respect. This ties into the design of topics (some systems have the concept of **ordered topics** with certain throughput limitations, and we could consider something similar if needed for consistency across local/distributed delivery).

* **Inspiration – Encore’s Type-Safe Pub/Sub:** A modern example of unifying developer experience is the Encore framework for cloud apps. Encore treats Pub/Sub as a first-class, type-safe object in your code. You declare a topic with a type, e.g. `var Signup = pubsub.NewTopic<*User>("signup", {...})`, and then use `Signup.Publish(...)` and presumably `Signup.Subscribe(...)` in your code. Encore’s system handles the details of whether it’s using Google Pub/Sub, AWS SNS/SQS, or a local NSQ instance under the hood, but your code doesn’t change when you go from local dev to cloud deployment. This is exactly the kind of seamless transition we want. We can emulate that by treating our Event Broker similarly: define topics in one place, use them uniformly, and let the runtime decide how to route. The fact that Encore highlights “no runtime dependencies and no code changes between local and cloud” aligns well with our need for location transparency. It’s proof that a **fully type-safe, cloud/distributed agnostic Pub/Sub API** is achievable.

In designing a **hybrid API**, we might take a phased approach: first introduce the improved API for the Event Broker (covering type safety and proxy usage as described above) – this tackles the distributed case. Then, look at the local `ActorEventBus` and see if its API can be matched to the new one. Perhaps we deprecate the old `actor.subscribe(event, callback)` in favor of using the unified eventBroker even for local events (the eventBroker could handle local actor addresses as topics, etc.). Or we implement the unified interface such that under the hood it knows how to attach either to local events or through the broker as needed. Merging them may require some internal refactoring (for example, ensuring the broker can handle high-frequency local events efficiently, maybe by short-circuiting delivery to the same process without serializing through persistence layers). But from the developer’s perspective, they won’t care – they’ll have one consistent way to subscribe to events anywhere in the system.

## Architectural Considerations and Minimal Redesign

Finally, considering **alternative architectures**: If minor enhancements aren’t enough, what structural changes could solve the problem at the root? Two ideas were posed: making the Event Broker a required core service (already discussed above) and possibly unifying the Event Broker with the ActorEventBus. Let’s evaluate these:

* **Event Broker as a Core Service:** By treating the broker like an integral subsystem of Actor-Web (much like a database connection or an HTTP server in a typical framework), we ensure every actor system has one. This means, for example, when the framework initializes, it always spawns an `event-broker` actor (or activates it if running distributed). Developers wouldn’t need to list it as a dependency explicitly; instead, the framework could provide an easy way to get a reference to it (like `system.getEventBroker()` or injecting it into context). More importantly, core framework code could integrate with it. For instance, the framework might automatically publish certain lifecycle events or state changes to the broker (if configured), or manage subscriptions as part of actor lifecycle. The **benefit** is tighter integration: we can optimize how events flow. The **drawback** is a slight loss of flexibility (you always pay the cost of having the broker running, and if someone truly doesn’t need distributed events, they still have it—though the cost is small, essentially one idle actor).

* **Merging ActorEventBus and EventBroker:** Right now, having two separate mechanisms is confusing and duplicative. A unified event system could handle both **in-component events** (which ActorEventBus currently does for local subscriptions) and **cross-component events**. Perhaps every actor could have a local event emitter for things only that actor’s children or internals care about, but any event meant to be globally observable goes through the unified broker. We could simplify this by saying: use the broker for everything, even local pub/sub, but allow the broker to differentiate scope. For example, a subscription could be marked as *local-only* (meaning the broker will only deliver events from the same host or same parent component) vs *global*. However, this might be over-engineering. Instead, an architecture where when an actor calls `subscribe(event, handler)`, the system decides if it can wire it directly (if publisher is local and known) or needs the broker (if publisher could be elsewhere) would be ideal. This is essentially making location transparency automatic.

* **Backwards Compatibility and Gradual Adoption:** We want to avoid breaking the pure actor model principles and not force a rewrite for existing code. Therefore, any new API (proxy or declarative) should be additive. The old way (manual SUBSCRIBE messages) could still work for advanced uses or under the hood. Over time, we can migrate the framework internals and examples to the new approach, proving that it can handle all use cases. If we do unify the event bus and broker, we’ll need to ensure that existing direct `subscribe` calls either continue to work or are easy to update (perhaps just changing which object you call subscribe on, e.g., `dependencies.counterService.subscribe` vs `dependencies.eventBroker.subscribe`). The unified design should accommodate both patterns at first, so that local components aren’t forced to incur distributed overhead unless necessary.

In conclusion, **improving the developer experience** of the Event Broker in Actor-Web is achievable by borrowing ideas from established actor frameworks and modern TypeScript techniques. The top priorities are to introduce **type safety for events** and a more ergonomic **subscribe/publish API (proxy or declarative)** that removes the need for manual message handling. By making the Event Broker usage nearly as simple as the local `subscribe` pattern, we will encourage adoption of the distributed pub/sub capabilities without the 4× code penalty. The end result should be an API where developers write something like:

```ts
// Example of the envisioned API usage:
const { eventBroker, counterService } = dependencies;
// Subscribe to a distributed topic with type safety and simple callback
const sub = eventBroker.subscribe("COUNTER_VALUE_CHANGED", (e) => {
  machine.send({ type: 'UPDATE_COUNT', newCount: e.newCount });
});
// (Optional) Subscribe to a local actor's event in the same fashion
counterService.subscribe("COUNT_RESET", () => {
  machine.send({ type: 'RESET_UI' });
});
```

No switches, no explicit `TOPIC_EVENT` handling, and no stringly-typed bugs – yet under the hood, these calls maintain full location transparency (they work whether `counterService` is in-process or remote) and use the actor message paradigm (the broker still sends messages, but the framework intercepts and translates them to callback invocations). Success will be measured by at least a **50% reduction in code** needed for broker-based subscriptions (which this approach should easily achieve), and by a safer, more intuitive developer experience that doesn’t sacrifice the powerful distributed features of the Event Broker. With these improvements, Actor-Web can offer the elegance of local event handling combined with the power of distributed messaging, in a unified and type-safe way that keeps developers productive and confident.

**Sources:**

* Akka Typed EventStream usage, illustrating simple subscribe and publish API with automatic removal of subscribers.
* Orleans Streams, demonstrating declarative `[ImplicitStreamSubscription]` and strongly-typed stream interfaces for events.
* TypeScript patterns for type-safe event emitters, showing how generic mappings of event names to payload types enable compile-time checks on `.on/.emit` usage.
* Example of enforcing type-safe unsubscribe by coupling the subscription handle to the event type.
* Encore framework’s approach to type-safe Pub/Sub, allowing topics to be defined as typed objects in code and used uniformly in local and cloud environments.
