Got it. I’ll analyze whether your current Actor-Web framework API design—targeting TypeScript developers across platforms—strikes the right balance between power and minimalism for a pure actor model. I’ll examine how it compares to the DX and architecture of leading actor-based and distributed systems frameworks (like Akka.js, CAF, Proto.Actor, XState, Dapr, Orleans, and others), with special attention to SSR, web workers, and location-transparent execution.

I'll let you know once I have findings and actionable recommendations.


# Review of Actor-Web Framework API Exposure

The current **Actor-Web Framework** API is **extensive**, covering everything from basic actor messaging to advanced features like event sourcing, security, and AI planning. While this comprehensive approach shows the framework’s power, it may be **“exposing too much”** to developers up front. Below, we review the API surface, identify potential issues with its breadth, and recommend how to streamline it for a better developer experience.

## Overview of the Current API Surface

The API reference as it stands enumerates a wide array of modules and types. Key categories in the documentation include **Core Actor types and creation**, **Message handling**, and numerous **advanced modules** (Virtual Actors, Event Sourcing, Capability Security, HTN Planning, Hybrid Memory, etc.). This implies a very broad scope:

* **Core API**: Fundamental actor primitives – e.g. `ActorRef` with messaging methods (`send`, `ask`), actor lifecycle (`start/stop`), child spawning, etc. These align with the framework’s goal of a **minimal, message-only interface**.
* **Utilities & Enhancements**: Additional helpers like phantom type utilities, discriminated union message handlers, and actor proxies to ease type-safety and message routing.
* **Advanced Features**: Subsystems for specialized needs:

  * *Virtual Actors*: Orleans-style distributed actors with location transparency and automatic activation.
  * *Event Sourcing*: Event store interface for persistence (append/read streams, snapshots).
  * *Capability Security*: Capability-based access control wrappers for actors.
  * *HTN Planning*: Hierarchical Task Network planner integration for actors (for AI task decomposition).
  * *Hybrid Memory*: Multi-layer memory (cache, vector search, knowledge graph) for actor “knowledge”.
  * *Performance & Monitoring*: System metrics and actor metrics retrieval.
  * *Error Types*: Custom error classes for various subsystems (security, planning, memory, etc.).
  * *Testing Tools*: Test actor creation, mock event stores, and expectation utilities (some already split into a `@actor-web/testing` package).

This breadth covers far more than the **“minimal API” principle** originally envisioned. In fact, the project’s own design emphasizes providing just the essentials for an actor model and hiding internal complexity. The official feature list highlights core strengths (pure message-passing, supervision, TypeScript support, XState integration, backpressure) **without mentioning** built-in planning or memory stores. This suggests that many of the advanced features are **either future extensions or not central to the framework’s primary use cases**.

*Notably, some advanced items (HTN planner, hybrid memory, etc.) do not appear to exist in the current codebase, indicating they are planned features rather than implemented ones (they’re absent from the repository search). This discrepancy between documentation and implementation could confuse users expecting those capabilities.*

## Issues with a Broad API Surface

Having such a wide API surface can introduce several problems:

* **Steep Learning Curve:** New users may be overwhelmed by the sheer number of concepts. Core usage (like creating an actor and sending messages) might get lost among optional features. A **minimal API that covers 90% of use cases** is easier to learn and remember. Exposing dozens of types and functions up front can hinder initial adoption.

* **Unclear Focus:** The framework targets both frontend and backend TypeScript developers for “all kinds” of software. Mixing front-end UI concerns with backend/AI features can dilute the focus. For example, a frontend web developer building UI components might not care about event sourcing or HTN planning, while a backend/agent developer might not need UI-specific helpers. Presenting everything to everyone can cause confusion about what the framework is primarily for.

* **Maintenance & Stability:** Every public API element is a contract that must be maintained. The more that’s exposed, the higher the burden to test and keep each piece consistent and bug-free. Some advanced features (e.g. a planner or memory store) are complex domains on their own. If they are not fully mature, exposing them publicly locks in their design prematurely. It’s safer to keep such features internal or experimental until proven.

* **Bundle Size & Performance:** Shipping all features by default could bloat the runtime, especially important for frontend use. The project touts a **tiny bundle (\~15KB gzipped)** for core functionality. Including rarely-used subsystems (like a vector database for memory or heavy planning logic) could compromise this. For web apps, developers appreciate a lean library and will opt out of large frameworks that include unnecessary code. Minimizing the default footprint by only **including necessary components** keeps performance optimal.

* **Overlapping Functionality:** Some utilities in the API might overlap with existing solutions or could be implemented by users if needed. For instance, `calculateMemoryRetention` (with a forgetting curve) or `createMessageRouter` are nice-to-haves but not essential. Providing too many convenience functions can actually make the API surface noisy, where a smaller set of well-chosen abstractions might suffice.

* **Audience Segmentation:** Advanced features like capability-based security and HTN planning suggest targeting specialized use cases (multi-tenant security, AI agent planning). Not every user will build such systems. Exposing these by default might give an impression that the framework is overly complicated or meant only for niche scenarios, possibly alienating the average developer looking for a straightforward actor model library.

In summary, a **“kitchen-sink” API** can dilute the developer experience. The framework’s value proposition (pure actor model, resilient state machines, etc.) might get lost if the user has to sift through unrelated features. Keeping the API surface focused and \*\*exposing only the **“bare minimum necessary”** for building efficient actor-based systems (as per the project goal) will make the framework more approachable and easier to maintain.

## Recommendations for Streamlining the API

To improve developer experience and stay true to the minimalistic design goal, consider the following adjustments:

**1. Define a Clear Core API vs. Add-ons:** Draw a line between the **core features** that every Actor-Web user will use, and **optional extensions** that only some will need. For example:

* **Core (Public)**: Actor creation (`createActorRef`), the `ActorRef` interface with its essential methods (`send`, `ask`, `observe`, `spawn`, `start/stop`, etc.), basic types (`ActorMessage` or a simplified event type), and fundamental utilities like mailbox and supervision (since fault tolerance and backpressure are core features). The Roadmap confirms these as the primary capabilities to deliver first. Focus documentation on these.
* **Advanced (Opt-in)**: Segregate features like virtual/distributed actors, persistence/event sourcing, security, planning, and memory into separate modules or at least separate documentation sections. These could live in separate packages (e.g. `@actor-core/persistence`, `@actor-core/ai`) or behind factory functions that are not automatically imported with the core runtime. This modular approach is common in mature actor frameworks: for instance, **Akka** provides a core actor library and distinct modules for clustering, persistence, streams, etc., allowing developers to include only what they need. Actor-Web can mirror this by keeping the core lean and offering advanced capabilities as add-ons.

**2. Trim the Public Surface:** Within each area, expose only what’s necessary for typical use. Some specific suggestions:

* **Hide Internal Types**: Types like `ActorId<T> = string & {...}` and phantom markers could be kept as an implementation detail. Developers can work with opaque `ActorRef` objects without knowing they are branded strings. The documentation could simply state that an `ActorRef` is a handle to an actor (as an interface with methods), rather than showing the underlying type alias which might confuse users. In fact, the README uses an interface view of `ActorRef` (with generics for event types) and that is likely easier to grasp.
* **Simplify Type Utilities**: Utilities such as `ExtractActorType` or `MessageFor<T>` might not need prominent exposure. If they are primarily used internally or in advanced typing scenarios, consider omitting them from the primary docs. TypeScript developers can often infer actor message types from their own defined event unions without needing a helper type. These could be mentioned in an advanced section or omitted until a strong use-case emerges.
* **Re-evaluate `createTypedActorRef`**: This function enforces compile-time actor type categories (using a `ValidActorTypes` union). It adds complexity by requiring a maintained list of type keys. If phantom typing is being deemphasized (since `ActorRef` now carries a generic), this function may be unnecessary. Developers could simply call `createActorRef(machine, { id, type })` and use TypeScript’s generic inference for the event types. If type-tagging actors is still desired, it might be better documented as a pattern (or handled via the actor’s machine definitions) rather than a separate API call.
* **Consolidate Message Handling API**: The core actor model encourages sending messages that the actor’s state machine handles. Introducing a separate `createMessageHandler` utility for pattern matching on message types might not be needed by most developers, especially if they use XState to handle events. Unless this is crucial for certain non-XState actors, it could be left out of the public API for now. Similarly, built-in type guards like `isAIAgentMessage` or `isWorkflowMessage` seem very domain-specific – these should either be removed or turned into examples in documentation (showing how one can write their own type guard for message unions), rather than first-class exports.
* **Limit Utility Functions**: Scrutinize each function in the Utilities section. For example, `generateEventId()` (to create unique IDs) might be useful, but a developer could also use UUID libraries or their own ID generation. If it’s just a thin wrapper, it might not warrant inclusion. `validateCapabilities()` is only relevant if the capability security system is used – if that system is optional, this function can be tucked away with it. By exposing fewer one-off helpers, the API feels tighter and more purposeful. Each utility kept should earn its place by being broadly useful in core actor workflows.
* **Testing API**: Testing support is important, but it could remain in a separate package as it is now (`@actor-web/testing`). Documentation can mention how to test actors without listing every test helper in the main reference. This keeps the runtime API focused. Developers who need testing will find the testing package documentation separately.

**3. Modularize Advanced Features:** Instead of bundling advanced subsystems in the core runtime, treat them as **plug-ins** or separate layers:

* **Virtual Actors / Distribution**: Provide this as a separate module or an optional initialization step. For example, a `createVirtualActorSystem()` could reside in an `@actor-core/virtual` package or under a namespace. Only users building multi-node or web-worker setups would import it. This way, the majority who run actors in a single-thread or single-process environment aren’t exposed to concepts like placement strategies or node IDs unless needed. This also allows evolving the distributed actor system without affecting core actor operation.
* **Event Sourcing**: Similarly, treat persistence as an add-on. The core actor model can define an interface or hooks for persistence (so that one can plug in an event store), but the framework itself might not need to ship a full event store implementation in v1.0. If event sourcing is a key feature for backend use, it could be delivered as `@actor-core/persistence` module where `createEventStore` and `EventSourcedActor` live. This separation follows precedent (e.g., Akka Persistence is a module separate from Akka Actors). It ensures frontend-focused developers aren’t carrying database or Redis integration code unnecessarily.
* **Capability Security**: This is a niche but potentially important feature in multi-actor agent systems. If it’s not commonly used in UI or simple apps, it could be made an optional wrapper. For instance, document it as an **advanced recipe**: “If you need to enforce permissions on an actor, wrap it with a secure proxy via `createSecureActor` (available from the security module).” By isolating it, the core actor API remains cleaner. Also, this avoids forcing all users to understand the Capability interface, which can be complex and application-specific.
* **HTN Planning & Hybrid Memory**: These are clearly specialized for AI agent scenarios. It would be wise to remove or de-emphasize these from the main API until they are fully fleshed out and there is demonstrated demand. They could potentially form their own high-level module (e.g., an “AI Agents add-on” that uses actors + planning + memory). In documentation, they might belong in an “Advanced AI Integration” chapter rather than the primary reference. This way, a developer uninterested in AI features can comfortably ignore that entire section. If these features are not yet implemented, it’s premature to include them in a public 1.0 API – doing so might set expectations that could delay release or require breaking changes later. It’s safer to **introduce them in a future version** once stable, rather than promise them now.
* **Performance Monitoring**: Basic metrics (like count of actors, message throughput) could be useful for debugging, but consider exposing them via a debug or devtools interface instead of as first-class API calls. Perhaps provide a simple way to plug in a monitor or query stats in development mode, without adding many methods to each actor or system. This could also be an optional import (e.g., `import { getSystemMetrics } from '@actor-core/monitoring'`). Casual users might never need to call `getActorMetrics`, so why put it in the primary interface?

By modularizing, you **achieve a cleaner separation of concerns**. Core stays small and focused on the actor model (which is what most users initially care about), and advanced capabilities can evolve separately. It also encourages contributions or use of alternative implementations – e.g., a community could develop a specialized memory plugin without touching core.

**4. Improve Documentation Structure:** Adjust the documentation to guide users through the API gradually:

* **Emphasize Core Usage First**: Start with a concise guide or reference to the absolutely necessary pieces (actor creation, sending messages, integrating with XState, observing state). This should map closely to the quick-start example in the README. Ensure that the first things a developer sees in the API docs are directly relevant to building a basic actor and using it, not the exotic features.
* **Clearly Mark Advanced Sections**: If advanced features remain in the same document, label them as “Advanced” or “Optional”. For instance, after covering the core API, have a header like “**Advanced Modules (Optional)**” and then detail Virtual Actors, Event Sourcing, etc. Introduce each advanced section with a note on when or why a developer might need it. For example: “**Virtual Actors** – Use this for distributed deployments or web workers; not needed for single-page apps.” Such context allows readers to self-select whether to delve in or skip. This way, the presence of advanced features doesn’t overwhelm those who don’t need them.
* **Split Documentation if Necessary**: You might even maintain separate documents or chapters: e.g., a “Core API Reference” vs. an “Extensions Guide” or individual guides for **Persistence**, **Security**, **AI Agents**. This approach is common. For example, Akka’s documentation clearly separates core actor usage from persistence and cluster features. Adopting a similar structure will mirror the modular code organization and prevent confusion.
* **Keep Examples Focused**: Ensure code examples in core sections don’t pull in advanced APIs. The quick start, for instance, demonstrates actor creation and usage with **just the core imports**. That’s excellent for newcomers. In advanced sections, provide targeted examples (e.g., how to set up an event-sourced actor) so only those interested will see them.
* **State of Implementation**: If some features are experimental or upcoming, be transparent about it. It’s better to mark HTN planning as “planned for future release” or keep it out of the 1.0 reference than to include it and risk confusing users when they don’t find it in the code. Transparency will also manage expectations – users know what’s ready to use versus what’s conceptual.

**5. Align with Design Goals:** Finally, every exposed API element should be weighed against the framework’s fundamental goals:

* The **vision** (per the roadmap) is to have a **“universal web runtime”** with state and side-effects managed via actors, and to do so with **minimal**, type-safe abstractions. To honor this, the API should feel *minimal* to the user, even if the framework internally is doing heavy lifting.
* Aim for **“pit of success”** design: Make the common tasks easy and apparent. For example, creating an actor and interacting with it should only require knowing about `createActorRef`, `send`, `ask`, etc., which are already well-defined. By contrast, a new user shouldn’t need to understand what an `EventStoreConfig` or `HybridMemory` is unless their project specifically requires that depth.
* Preserve **type safety and simplicity**: The framework already emphasizes zero-`any` types and familiar patterns (like an RxJS-like observable). Keep the API surface oriented around these familiar concepts. If an advanced feature can’t be presented in a simple, type-safe way, that might be a sign to keep it out of the core experience.

**6. Draw Inspiration from Similar Frameworks:** As a point of reference, many actor model frameworks succeed by modularizing:

* **Akka (JVM)** exposes a small Actor API, with modules for persistence, clustering, etc., which can be added as needed. This allows enterprise users to opt into powerful features, while others use just the core.
* **Orleans (Microsoft .NET)** focuses its public API on the virtual actor concept and hides much of the complexity (e.g., Orleans auto-manages activation and persistence behind interfaces). Actor-Web could similarly **auto-manage aspects internally** without exposing knobs unless necessary.
* **Proto.Actor (.NET/Rust)** and other modern actor libraries often separate the core messaging from add-ons like persistence or cluster. Following this practice will make the framework feel lightweight or heavyweight depending on what the developer chooses to use – a flexible approach.

By following the above steps, the Actor-Web Framework can maintain a **“best of both worlds”**: an elegant, minimal API for common usage, with powerful extensions available for those who need them. This improves the developer experience by reducing cognitive load and potential confusion, all while keeping the framework **scalable** for complex scenarios. The guiding rule should be to **“expose the bare minimum necessary”** for the actors to be useful and efficient, and no more. Everything else can be opt-in. This will make the framework more approachable, and signal clearly which parts of the API are stable core vs. which are optional advanced features.
