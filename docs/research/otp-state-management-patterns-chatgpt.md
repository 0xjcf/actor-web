# OTP-Inspired State Management Patterns for Actor-Web Framework

## OTP State Update Patterns: Returning New State

Erlang/Elixir’s OTP **gen\_server** provides a classic pattern for state updates. In OTP, an actor (process) maintains internal state that is **updated by returning a new state from each message handler**. For example, an Elixir `GenServer.handle_call/3` callback returns a tuple like `{:reply, reply, new_state}` – OTP uses that `new_state` for the next message loop. This functional style ensures no shared mutable state: the actor’s state is replaced immutably on each message.

This pattern can be mirrored in TypeScript. For **context-based actors**, instead of mutating `machine.getSnapshot().context` directly, the actor’s `.onMessage` handler can **return a new context object**. The actor system would then set this as the updated state for subsequent messages (similar to OTP’s loop). This is precisely how some actor libraries for JS/TS work. For example, the Nact library (inspired by Akka/Erlang) uses a function signature where **each message handler receives the current state and returns a new state**. The returned value becomes the “next state” of the actor. In Nact’s docs, an actor initialized with `state = {}` returns either the unchanged state or a copied state with modifications, and that return value is used as the next state. This aligns with OTP’s approach and ensures **pure message handling** – state changes only occur via message processing, not via external mutation.

Another illustration is a custom actor loop implementation in F# (by Bartosz Sypytkowski) where the actor processes messages with a line `state <- handler(state, msg)`. Here `handler` is a function that takes the current state and message and **produces a new state**, which is then assigned to the actor before processing the next message. This demonstrates the same idea: treat the state as an immutable data structure and **update it by replacement** on each message. Adopting this pattern in your framework would mean the `.onMessage` for a context-based actor could return either a new context or an instruction to update state.

**Why use this pattern?** It upholds the **actor model’s encapsulation** – only the actor itself can modify its state, and it does so in a controlled, serializable way. It’s analogous to Redux-style reducers but for actors. It avoids unpredictable side-effects because state isn’t mutated mid-message; instead, a new state is constructed. This also aligns with **OTP’s functional principles** (Erlang’s immutable data): each state change yields a new state term. It keeps **type safety** intact (the context has a defined interface) and avoids any `any` casting since you’d use the concrete context type for the return value.

One practical approach is extending your `MessagePlan` to allow something like `{ state: NewContext }` as a result from `.onMessage`. The actor runtime would then replace the internal context with `NewContext` for the next message. This is similar to how Erlang’s `gen_server` loop continues with `NewState` after a handler. Indeed, **OTP’s proven pattern is to return the new state from the handler**, and your framework can adopt that to let context-based actors cleanly modify their state.

## Dynamic Behavior Switching with the “Becomes” Pattern

In modern actor systems, an actor can **change its behavior at runtime** – often called the *“become”* pattern. The classic actor model actually considers `become` a fundamental primitive: *“the classic actor model uses `create`, `send`, and `become` primitives… To change state, actors become a new actor with different behavior.”*. In practice, this means an actor can swap out its message handler logic on the fly.

**OTP Approach:** Erlang’s OTP does not have an explicit `become` function in `gen_server`, but it achieves dynamic behavior via state data or different callback modules. For complex scenarios, OTP offers **`gen_statem` (state machine)** which can have multiple states (each with its own handlers). A process can transition to a new state (S → S’) with a new handler function for that state. In plain Erlang, one can manually implement `become` by tail-recursing into a different function (representing a new behavior). For example, an actor’s receive loop can call a different function to handle future messages – effectively *becoming* a new behavior.

**Akka and Actor Frameworks:** In Akka (Scala/JVM), the **untyped actors** API had `context.become(newReceive)` which allowed an actor to swap its message handling function at runtime. In **Akka Typed**, the model is more functional: instead of mutating behavior, you return a new Behavior from the message handler. For instance, you might define an actor as a function `behavior(state) => Behaviors.receiveMessage(msg => {...})`. On receiving a particular message, you can return a **new behavior instance** (with potentially new state or handling logic) instead of `Behaviors.same`. This effectively switches the actor’s future behavior. A concrete example from Akka Typed shows an actor that in each message can either return `Behaviors.same` (keep current behavior) or call itself with a new state to change behavior: rather than always returning the same behavior, it calls a factory method with updated state (e.g. `emotionalFunctionalActor(happiness + 1)`). This pattern means *the actor will handle the next message with new logic and state*, i.e. it “became” a new actor behavior while keeping the same identity.

In **TypeScript/JavaScript actor libraries**, similar patterns exist. The **actor-js** project, for example, explicitly provides `context.become(newHandler)` to designate a new message handler for subsequent messages. This is directly inspired by Akka’s API. Using this, an actor could receive a `BECOME_MULTIPLIER` message and respond by calling `context.become(multiplierBehavior)`, where `multiplierBehavior` is a function handling future messages differently.

For your framework, implementing a *becomes* pattern could mean allowing `.onMessage` to signal a behavior swap. This could be done by returning a special `become` instruction with a new behavior definition (perhaps using the same fluent API to define a new `.onMessage` set). The **MessagePlan** could be extended to `{ become: NewBehavior }`. Alternatively, since your actors are defined via a builder, you might encapsulate behaviors as objects and let an actor hold a reference to its current behavior, updating that reference when a switch is needed. The key is to ensure the switch is **type-safe** – the new behavior should handle the same message type (or a subset if narrowing). This dynamic switching must also integrate with supervision and the ask-pattern (e.g. pending asks might still go to the correct handler).

**Real-world analogs:** The *become* pattern is widely used for **protocol actors** (an actor that goes through phases). For example, a user session actor might start in a `idle` state but upon a “LOGIN” message, it becomes a `loggedIn` behavior which handles messages differently (ignoring or treating some messages as errors until logout). With *become*, this is elegant: the actor simply swaps to the `loggedIn` handler. Without an explicit become, one can still achieve this by maintaining a `mode` flag in context and doing `if`/`switch` inside the handler, but that’s less clean and not OTP-idiomatic. OTP would encourage either splitting into multiple processes or using a state machine behavior for clarity.

In summary, **dynamic behavior switching** can be achieved by **changing the actor’s message handling function at runtime**. This is inspired by OTP’s design (processes can change state and even code on the fly) and implemented in many actor frameworks. Embracing this in your framework will allow features like the `BECOME_MULTIPLIER` in your example to be implemented cleanly (the actor literally becomes a multiplier behavior). It’s important to ensure any become mechanism doesn’t violate actor isolation – it should be triggered by a message or internal action, not external intervention, to remain pure.

## State Management in Other Actor Frameworks (Simple vs Complex State)

Different actor frameworks handle state in varying ways, from simple context variables to integrated state machines:

* **Akka (JVM):** Actors encapsulate state by default. In untyped Akka, an actor class could have mutable fields (since only the actor’s thread accesses them). In practice, many Akka developers used **immutable messages and mutable actor state** for simplicity (e.g. increment a counter field). Akka’s style guide for Typed Actors, however, encourages a more functional approach: use immutable state and return a new behavior with updated state (as shown above) for clarity and to avoid mistakes. Both styles (mutable internal field vs. returning new state) are thread-safe in Akka due to the single-threaded execution per actor. Akka also provided an **FSM utility (Finite State Machine)** in classic actors (and patterns in Akka Typed) to manage more complex multi-state workflows. This is analogous to using XState in your framework. **Simple state** (like a counter or flag) is often handled with just variables or simple context in Akka, whereas **complex state machines** (with multiple distinct states and transitions) might be implemented with the FSM trait or by an actor manually switching behaviors (become) for each state.

* **Orleans (Microsoft .NET):** Orleans uses the *Virtual Actor* model. A *grain* in Orleans is essentially an object that acts like an actor. State is typically just fields in the grain class, and you update them by assignment in your grain methods. **State updates are persisted** optionally via Orleans’ persistence APIs. This is more of the “active object” approach – the actor is an object with methods, and each invocation is serialized. Orleans doesn’t have an explicit behavior switching concept; instead, you might model different behaviors as different grain types or by internal state flags. Simple state is directly mutable (since each call is isolated to one thread by Orleans’ runtime), and complex state logic is managed in code (Orleans doesn’t provide a separate state machine abstraction, you implement the logic in if/else or by calling other grains). The key takeaway is Orleans prioritizes **easy state management via normal OO patterns** (with thread safety guaranteed by the framework) but lacks OTP-style dynamic behavior switching.

* **Proto.Actor:** Proto.Actor is a cross-language actor framework (implemented in C#, Go, etc., and experimental JS). In Proto.Actor, an actor can be defined by a class with a `Receive` method (where you can switch on message types). State can be just fields on the class (mutable, since again only one message at a time is processed). Alternatively, you can define the actor’s behavior as a **function of state and message** similar to the functional style. The Proto.Actor documentation emphasizes not sharing mutable state between actors and keeping messages immutable. It even supports **persisting state** (Proto.Actor Persistence module) for recovery. Proto.Actor doesn’t natively have a `become` API in the high-level API, but you can achieve similar results by controlling which messages you handle or by having the actor context store a pointer to the current handler (much like your design could). **Simple vs Complex**: For simple state, direct field updates inside the actor are idiomatic. For complex behavior changes, you might instantiate different actor instances or use a finite state machine pattern manually. The **bootcamp example** from Proto.Actor shows that the *actor model simplifies concurrency by isolating state*, and it recommends immutable messages to avoid sharing state incorrectly.

* **Nact (Node.js actors):** As mentioned, Nact leans heavily into **immutable state updates** (Redux-like). A Nact actor is created with an initial state and a reducer function. To handle complex scenarios, Nact encourages breaking things into more actors or using the fact that you can pattern-match on messages and maintain a rich state object. There isn’t an explicit “become” in Nact; instead, you’d incorporate a mode in the state if needed (or spawn a new actor for a different role). Simple state changes (e.g. toggling a flag) are done by returning a copy of the state with that flag changed. For more complex behavior, since Nact doesn’t have formal state machine support, one might integrate a state machine library or manually manage a state field.

* **Akka.NET and others:** They mirror the patterns above. Akka.NET’s actors behave like Akka (mutable fields allowed). There’s also **Persistence** patterns (event sourcing) in many frameworks for maintaining complex state over time with durability – e.g. Akka Persistence or Orleans persistence. This is tangential, but relevant if *state versioning/rollback* is of interest: these frameworks allow you to reconstruct an actor’s state from a journal or snapshots (for example, Nact has a notion of **snapshotting** actor state to disk). That means complex state changes can be persisted, and if something fails, the actor can be restarted and *roll back* to a previous snapshot and replay events – a form of state rollback in a broader sense.

**Key insight:** Many frameworks draw a line between “simple stateful actor” and “state machine/fsm actor”. OTP itself suggests using a simple `gen_server` for most cases, and only using `gen_statem` when you truly need formal state machine features (like state-specific handlers or postponing events). The overhead difference is minor (OTP notes a gen\_statem call might be \~3.3µs vs 2µs for gen\_server, a small cost) – meaning you shouldn’t fear using a state machine when it helps clarity. But if not needed, a simpler pattern is fine. Your framework’s approach of **`.withContext` vs `.withMachine`** mirrors this philosophy: provide a lightweight way for simple cases and a more powerful mechanism for complex cases. This hybrid approach is validated by OTP’s long-standing design.

In summary, actor frameworks **handle simple state by local mutation or small immutable replacements**, and **complex state by either leveraging built-in FSM support or encouraging a different abstraction (like splitting into sub-actors or using external state machines)**. The pure actor model principle (“no shared state, communicate by messages”) underpins all of them, but the implementation can vary from mutable fields to returning new state structures.

## Immutability and State Update Best Practices

One fundamental rule across actor systems is **never share mutable state between actors**. Messages should be immutable data structures – this ensures you don’t accidentally create race conditions by two actors referencing the same object. Your framework should continue to enforce that (for example, by copying data in `.ask` or documenting that messages must be immutable objects). This addresses the “pure actor compliance” ✅ in your criteria.

Within an actor, however, you have a design choice: use immutable updates or allow mutable state. **Erlang/Elixir** force immutability (you create new state terms), whereas frameworks on the JVM or .NET often allow mutation internally. The **best practice** often comes down to **clarity and correctness vs. raw performance**:

* **Immutable state updates (functional style):** As in the OTP and Nact patterns, you treat the actor’s state as an immutable value that is replaced on each update. This is very safe – you never have lingering references to old state, and you could even keep prior state versions (for debugging, or implement an undo by reverting to an old state snapshot since you have them as separate objects). It aligns with the idea that each message handling is a pure function from `(oldState, message) -> (newState, outputs)`. If you need **state versioning**, this approach is natural: you can log or store each state as it changes (or diffs). Many event-sourced systems take this approach: instead of mutating state in place, they record events and derive new state, which makes rollback as simple as replaying up to a point. Immutability also plays well with **time-travel debugging** and testing (you can simulate a series of messages and assert the final state easily).

* **Mutable internal state:** This is acceptable in many actor systems because **the actor is single-threaded**, so traditional concurrency issues don’t arise. Mutating a counter or changing a field in place is more efficient than copying an entire state object, especially if state is large. Performance-wise, *avoiding copies can be important* if state is very big or updated extremely frequently. A Stack Overflow discussion notes that *shallow cloning an object (like copying a 400-element array) is much slower than in-place mutation of a field*. In JavaScript, frequent object copying can put pressure on the garbage collector. If your actors manage very large context objects or big data, an immutable approach could become a bottleneck (due to GC thrash). In those cases, a **pragmatic approach** is to allow internal mutation but keep that detail encapsulated (no other actor sees those intermediate states).

**Best of both worlds:** Some frameworks employ **persistent data structures** (as in Clojure or Immer.js) to mitigate copy costs – they allow *structural sharing*, so that “copying” a state only copies changed parts. In TypeScript, one could use libraries or simple patterns (like updating shallow copies only). Given TypeScript’s capabilities, you can make a shallow clone of a small context quite cheaply (e.g. using object spread) and it’s unlikely to be a performance issue unless done millions of times per second. For high-throughput scenarios, measure and consider where mutability is needed.

In OTP’s world, the BEAM VM is highly optimized for immutable terms and can handle millions of messages per second with new state terms because of its GC and scheduler design. In Node.js, **millions of messages** can also be handled (as actor model tests like Proto.Actor’s benchmarks show), but you may need to be more mindful of memory. If performance tests show a bottleneck, you could allow critical actors to opt into an imperative style (e.g. by using a machine that simply mutates context, or by exposing an API on `machine` to update context directly with care).

However, it’s generally wise to **start with an immutable approach for correctness and simplicity**, and only optimize to mutable if profiling shows it’s needed. This ensures your framework remains easier to reason about – each message doesn’t mysteriously alter state without the framework knowing. The immutable pattern also makes **hot code upgrades and restarts safer**, since you have clear state snapshots.

## Hot Code Reloading (OTP Style Code Upgrades)

Hot code reloading – updating an actor’s logic without stopping the system – is a hallmark of Erlang’s OTP but quite rare elsewhere. In OTP, this is achieved by loading a new version of a module and using a callback `code_change/3` in the actor’s behavior. When an upgrade is triggered, the running process invokes `code_change(oldVsn, State, Extra)` which should return the transformed state for the new code. This allows changing the **shape of the state** if needed to fit the new code’s expectations. After `code_change`, the process begins executing the new code version with the new state. This mechanism enables *non-stop upgrades* of running systems.

Applying true hot code swapping in a TypeScript environment is challenging – JavaScript engines don’t support replacing code of a running closure on the fly. There are limited analogies: e.g. in development, tools like Webpack’s Hot Module Replacement (HMR) can swap module code, but that typically requires re-running initialization. In Node.js, one can load a new version of a module and then have existing objects call into it, but live functions aren’t easily replaced without cooperation.

That said, you can incorporate some ideas:

* **Pluggable Behavior Modules:** Your actors could be defined in a way that their behavior is encapsulated (e.g. an object with handler functions). In theory, one could load a new version of that object and instruct the actor to switch to it (similar to OTP’s `{change_callback_module, NewModule}` in `gen_statem`). OTP even allows switching the callback module for a running process, though it’s noted as an esoteric feature. In TS, you’d have to implement this intentionally – e.g. by sending a special message like `UpgradeBehavior(newLogic)` to an actor which then uses `become` internally to switch to the new logic. This is a controlled form of hot code swap (not automatic, but via message).

* **Restarting with New Code:** A simpler approach (used commonly outside Erlang) is rolling upgrades: deploy new code and gradually restart actors using it. If your actors are supervised, you could implement a strategy where an upgrade message causes an actor to stop and let its supervisor restart it, which will load the new code (assuming the code is updated in the binary). The actor could persist its state before stopping (to a store or to the supervisor) and the new instance could load it – effectively achieving an upgrade with state continuity.

* **Hot-swapping in UI context:** If this framework is used in a web app, you might leverage HMR during development to replace actor code. Perhaps the actor definitions could be re-imported and you call some internal method to swap out the behavior objects (similar to how React Fast Refresh swaps component implementations). This is a complex area, but since OTP was mentioned, it’s worth noting **OTP’s robust solution**: they design the system for upgrades with minimal downtime, using structured releases and versioned state transformations.

Outside of Erlang, very few frameworks provide general hot code reload for actors. Akka doesn’t – you typically deploy new code and restart actors (though Akka Cluster can do rolling upgrades). Orleans also expects a redeployment for new code (grains will be activated with new code version after old ones deactivate). **The OTP way remains unique**. If hot reload is a target feature for your framework, you could implement a limited form: e.g., keep actor definitions in a registry such that they can be replaced, and have actors poll or get a message to swap their behavior. But be cautious: ensuring type safety and state consistency through such a swap is hard (OTP handles it with the `code_change` hook explicitly converting state).

In summary, **OTP’s hot code reloading** uses a structured approach (a callback to transform state and swap code version). You can take inspiration by allowing actors to handle a special “upgrade” event where they replace their behavior logic and adjust context. This would fulfill the OTP-like hot upgrade scenario, but it’s an advanced feature. It might be acceptable initially to document that **hot code reload isn’t natively supported** (since in JS one usually restarts the service or refreshes the page for new code), unless this is a strict requirement.

## Hybrid Approaches: Simple Context and XState Machines Together

Your framework aims to support both **straightforward state management** and **complex state machines** under one roof. This hybrid model is sensible and there are precedents:

OTP, as noted, has both `gen_server` (generic server with arbitrary state handled manually) and `gen_statem` (formal state machine engine) and even `gen_fsm` (older finite state machine). Developers choose one based on complexity needs. A simple counter or cache fits `gen_server`, whereas a protocol handler with distinct modes fits `gen_statem`. Importantly, OTP assures that the **overhead of using the more complex abstraction is not too high**, so one shouldn’t hesitate if needed.

In the JavaScript world, XState itself is built on the actor model ideas. **XState v5** explicitly models actors and state machines equivalently – every state machine is an actor, and actors can spawn state machines. This means integrating XState with your actors is conceptually aligned: an XState machine can be the “brain” of an actor. For complex logic, using XState (with its explicit states, transitions, guards, etc.) can prevent bugs and make visualization possible (via statecharts). However, not every actor’s needs justify a full statechart. Often, a simpler **context + if/else** logic is enough.

**Patterns for integration:**

* **Encapsulate XState as a dependency** – You already allow `.withMachine(myXStateMachine)`. Ensure that the `machine` in `.onMessage` for a machine-based actor exposes both **actions (send, etc.)** and **context queries** safely. For example, `machine.send('EVENT')` is how you update an XState machine’s state. That’s fine for complex flows. For a context-based actor, you might simulate a minimal state machine: e.g., under the hood, create an XState interpreter with a single state node whose context is your object. Then you *could* use `machine.send()` to send a special event that carries a partial context update, and have an internal transition that merges context. This is one way to unify the interface. But it might be overkill – an easier way is as discussed: just return new context in the onMessage.

* **Behavior Composition:** Perhaps an actor could use *both* patterns: e.g., an actor might mostly run as a simple context-based actor, but in response to a message, it might spawn a **child actor** that is an XState machine to handle a sub-task. This is analogous to how one might design an Erlang system: one process does high-level coordination but spins up another process running a finite state machine for a complex sub-protocol. Since your framework is for web and Node, a web component could have a main actor for its UI logic and spawn an XState-based actor for, say, a multi-step form workflow. The two can communicate via messages. This keeps the simple parts simple while using statecharts for the complex parts. Your framework’s *fluent API* should make spawning child actors straightforward (perhaps via `machine.createChild(behavior)` inside onMessage).

* **State Transitions without full XState:** You might implement lightweight utilities for context-based actors, such as a **tiny transition map** or state enum in context. For example, the session actor could have `status: 'idle' | 'active' | 'expired'` in context, and you could provide helper methods like `machine.transition(newStatus)` that under the hood just updates the context.status (or triggers a context update event). This gives a flavor of state machine (explicit states) without requiring an entire XState definition. It’s a design choice: simplicity vs. formality. Some frameworks (like Akka FSM) basically do this – they let you define states and transitions in a simpler DSL than a full statechart. You could emulate that idea: e.g., `defineBehavior.withContext(...).states({ idle: idleHandler, active: activeHandler, ... })` to define different handlers per state. That’s essentially implementing a mini state machine in the actor. If such a pattern emerges frequently, it might be worth providing.

Ultimately, the **hybrid approach is about flexibility**. Ensure that the core actor system (supervision, messaging, etc.) treats both context-actors and machine-actors uniformly. They both should be first-class actors. The difference is in how they manage internal transitions. As you integrate these patterns, keep performance in mind (XState, while efficient, has more overhead than a plain object update). Fortunately, as OTP notes, the overhead for using a state machine is often negligible for most workloads, especially compared to the complexity it abstracts away.

## Performance Considerations in State Update Patterns

Performance in actor systems often comes down to message throughput and how efficiently state updates can be applied. Here are key points related to the patterns discussed:

* **Messaging Overhead:** Actors achieve high throughput by avoiding locks and context switches. For example, millions of messages per second can be processed if actors are scheduled optimally across threads, because each actor processes sequentially without locking. In your framework (likely running on Node’s event loop or web workers), the bottleneck will usually be the single-threaded nature rather than the actor logic itself. If using Node, you can cluster or use worker threads to get parallelism at the actor level, but within one thread, an actor processing one message at a time is very fast (just a function call). The overhead of using an actor vs. a plain function call is mostly in the mailbox and dispatch mechanism, which you likely have optimized with Promises or task queues.

* **State Copy vs Mutation:** As mentioned, copying state (especially large objects) has a cost. If an actor’s state is small (a few primitives or a small object), returning a new object on each message is trivial. But if state is a large structure (say a large map of data that only changes slightly per message), constantly cloning it could hurt performance. In such cases, frameworks either use **structural sharing** (only update a small part, reuse the rest) or just mutate. Since JS objects don’t automatically do structural sharing, you might design your state updates to be granular. For instance, if your context is `{count: number, status: string}`, cloning that is negligible. But if context held a big array or something, you’d try to update just one element. Consider documenting that large state should perhaps be handled via references or splitting into smaller pieces (or even external storage if truly large).

* **XState machine performance:** XState v5 is quite performant but naturally adds some overhead per message (it has to match events to transitions, update context, etc.). The benefit is the correctness and clarity for complex flows. Use XState when the complexity merits it – the slight overhead per transition (microseconds) is usually acceptable. Also, XState can be run in a web worker if needed to offload heavy logic. For high-frequency simple messages (like a hot counter incrementing 100k times a second), a plain context actor will outperform a full statechart due to lower overhead. So it’s good that your framework allows opting out of the heavy machinery when not needed.

* **Memory Footprint:** Each actor carries its state. With millions of actors (if that ever happens in a web or Node scenario, which is less likely than on the BEAM), memory can add up. OTP processes are extremely lightweight (both in terms of scheduler and memory for state). In JS, an actor is probably a plain object plus maybe an XState interpreter instance. That’s still pretty lightweight, but be mindful of closure scopes (if using closures to store state) as they can’t be easily garbage-collected piecemeal – using explicit context objects that can be dropped or replaced may actually be more memory-friendly than capturing a large environment in a closure. In other words, returning new state objects (which become garbage eventually) might be better than a long-lived closure that grows. Fortunately, V8 is good at garbage collection for short-lived objects.

* **Throughput vs Latency Trade-offs:** The blog example by Bartosz S. implements batching of messages (processing up to 300 messages in one go) to reduce scheduling overhead. Akka does similar via its dispatcher throughput setting. In your framework, if running on Node’s event loop, you might not batch to avoid blocking the loop too long (latency). But if an actor gets flooded, a batching strategy could improve overall throughput. This is more about the actor runtime than state pattern, but it’s relevant: if you choose an immutable return-new-state approach, handling 100 messages might create 100 objects in quick succession. Batching could allow those to be optimized or merged, but again at the cost of responsiveness. It’s something to consider if performance testing shows message handling overhead dominates.

In conclusion, **measure and balance**. The patterns recommended (immutable state updates, behavior switching by returning new behavior) are aimed at **correctness and modeling power** (and have their roots in highly concurrent systems like OTP). They can be implemented efficiently in TypeScript, especially for the typical scales of web/Node applications. If you do encounter performance issues (e.g., high GC from too many state objects), you can introduce optimizations such as pooling, structural sharing, or selective mutability as internal enhancements – without changing the user-facing API.

By adopting these patterns, you ensure: **simple state updates** ✅ (via returning new context), **behavior switching** ✅ (via become/new behavior returns), adherence to **pure actor model** ✅ (no shared mutable state, only message passing), **type safety** ✅ (the context and message types are well-defined), and you leverage **OTP principles** ✅ that have been battle-tested in scalable systems. All of this sets a strong foundation for your Actor-Web framework to be robust, flexible, and maintainable in both browser and server environments.

**Sources:**

* OTP GenServer state handling, OTP code change for upgrades
* Nact (Node actor library) state update example
* RocktheJVM Akka Typed example (functional state becomes)
* Bartosz Sypytkowski’s actor implementation (state loop)
* Actor-JS (Shane Osbourne) become API
* “43 years of Actor Model” – become primitive
* Proto.Actor guidelines on immutability
* Akka documentation on actor model and performance
* Erlang/OTP gen\_statem vs gen\_server advice
