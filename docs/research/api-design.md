Perfect. I’ll research how TypeScript-focused actor frameworks and relevant patterns from mature systems handle the distinction between actor definitions and instances, the DX trade-offs, and XState integration strategies. I’ll also explore migration-friendly patterns and how conditional types impact polymorphic APIs.

I’ll get back to you shortly with a breakdown that prioritizes developer experience while preserving architectural integrity.


# Actor Creation API Design: Balancing Definitions vs Instances

## Actor Definitions vs Instances in Other Frameworks

**Separation of Behavior and Instance:** Many actor model frameworks distinguish between an actor’s **definition (behavior)** and the **actor instance (reference)**. For example, **Akka** uses `Props` to define an actor’s behavior, and spawning that `Props` via an `ActorSystem` yields an `ActorRef` handle. In **Proto.Actor** (a .NET/Go framework), the pattern is similar – you first create a **Props** (blueprint) and then **Spawn** it to get a running actor (identified by a `PID`). This two-step approach enforces that actors are created within a system and emphasizes the actor model’s hierarchy and supervision.

**Unified Instance Creation:** In contrast, some frameworks present a unified API where actor creation directly returns a usable instance without exposing a separate definition object. **Orleans** (virtual actor model) is an extreme case: actors (grains) “always exist” virtually and **cannot be explicitly created or destroyed by the user**. Developers simply obtain a grain reference (e.g., `GetGrain<T>(id)`) and call methods on it; the Orleans runtime instantiates the actor on demand behind the scenes. This provides a very high-level DX (developer experience) — no explicit spawn calls at all — at the cost of hiding lifecycle control (the system manages activation/deactivation automatically).

**Developer Experience Trade-offs:** The **separate definition** approach (Akka, Proto.Actor, etc.) can improve architectural clarity and flexibility. It allows configuration of an actor’s behavior (e.g., what class or function to run, deployment options) independent of its instantiation. This can make testing and composition easier, and aligns with strict actor model principles (requiring an ActorSystem context to spawn actors). However, it introduces extra boilerplate: the developer must always go through a system or context to get a working actor reference. On the other hand, **unified or implicit creation** (Orleans, or libraries like nact/comedy in JS) emphasizes convenience – you call a single function to get a ready-to-use actor. For example, the JS library **nact** provides a `spawn()` function that you call with a parent reference and a behavior function, returning an actor reference in one step. Similarly, **Comedy.js** allows creating a child actor directly via `rootActor.createChild(...)` which returns a promise for the actor instance that has `send()` methods, etc. The trade-off is that these frameworks might manage a default actor system under the hood or constrain actor placement (e.g. Comedy requires actors be created by parent actors, not arbitrarily, to maintain hierarchy).

In summary, **most mature actor frameworks use separate APIs for definition vs instance** (e.g. Props/Behavior vs ActorRef/PID) to enforce clear lifecycle management. **Developer experience varies:** A unified approach (or automatic actor existence) simplifies usage but can obscure when/where actors are created and running. A separated approach requires a bit more ceremony (always spawning via a system) but aligns with location-transparency and supervision semantics. The key is to find a balance where **common cases are easy** (maybe via a convenience method) while still allowing advanced control when needed.

## Integrating XState State Machines with a Custom Actor System

**XState’s Actor Model Expectations:** XState (v5) treats **state machines as actors** and provides a `createActor(machineOrLogic)` API that returns an **actor instance** (an *Interpreter* in v4 terms) which has methods like `.start()`, `.send()`, and `.stop()`. In XState’s model, you first define your **actor logic** (e.g., via `createMachine(...)` or other helpers like `fromPromise`, `fromCallback`, etc.), and then `createActor(logic)` gives you a live actor. This actor isn’t immediately running; you have to call `actor.start()` to initialize it, after which you can call `actor.send(event)` to send messages. The important point is that XState’s **developer experience** assumes `createActor` yields an object ready to start and interact with, without requiring an external system to spawn it – XState implicitly creates an actor system behind the scenes when you start the actor.

**Adapter/Wrapping Strategy:** To integrate XState machines into a custom actor system, a common approach is to **wrap the XState interpreter in a custom actor**. This means your framework could provide a specialized `XStateActor` or accept an `XStateMachine` in the `createActor` config. Under the hood, the library would take the provided XState machine (or machine config) and do something like: `const service = createActor(machineLogic)` (using XState’s API) and possibly immediately `service.start()` depending on desired behavior. The returned object to the user would be an actor **instance** conforming to your framework’s `ActorPID` interface, but internally it delegates to the XState service. In practice, this could preserve the familiar XState methods: for example, your `GitActor` (if based on an XState statechart) could be started and sent events just like a normal XState service. The goal is to **preserve XState’s actor interface** while still registering the actor with your system for supervision, messaging, etc. This likely means the `ActorDefinition` for an XState-based actor would encapsulate the state machine logic and the integration code.

**Wrapping vs. Native Spawn:** Another design decision is whether to **treat XState actors as foreign entities or native actors**. Best practice would lean toward treating them as *just another type of actor logic*. XState’s own documentation describes “actor logic” as the blueprint or brain of an actor. In your framework, you can view an XState state machine as an actor logic provider. Thus, when `createActor` is called with an `XStateActorConfig`, your library can internally create the XState interpreter and return it (or a thin proxy around it) as the actor instance. This way, the user gets an object with `.send()`/`.stop()` that they expect. Crucially, you’d also want to handle messages from outside: if other actors send messages to this actor, your wrapper should feed those into the XState machine (probably via `service.send(event)`). Likewise, you may want to hook XState’s termination (when the machine stops or reaches a final state) to inform the actor system that the actor is stopped.

**Maintaining XState semantics:** XState has its own lifecycle and event queuing semantics (it processes one event at a time and has a snapshot state, etc.). Integrating into a broader actor system, ensure that doesn’t conflict with your system’s messaging model. Typically, it’s fine because XState’s interpreter is essentially single-threaded and non-blocking, similar to how a JavaScript actor would behave. To preserve the **developer experience**, you might choose to automatically **start** the XState actor upon creation (since XState requires a `.start()` call). For instance, if the common case is that users want the actor running immediately, your wrapper could call `start()` internally (or provide an `autoStart: true` option) so that `createActor(xstateMachineConfig)` returns a running actor. Alternatively, you could expose the start/stop controls to the user, mirroring XState’s explicit start. There’s no one-size-fits-all, but **the guiding principle is to make using XState in your system feel natural** – developers shouldn’t need to know about `ActorSystem.spawn` just to use a statechart. Many developers expect to write something like:

```ts
const gitActor = createActor(gitMachineConfig);  
gitActor.send({ type: 'PUSH', payload: { /*...*/ } });
```

and have it “just work”. Achieving that might involve behind-the-scenes calls to your `ActorSystem` to spawn the actor and then returning a proxy that exposes `send/ask` etc. By treating XState machines as first-class citizens in your actor system (via an adapter), you preserve their familiar interface and integrate their behavior into your model.

**Note:** If direct integration proves complex, a simpler interim solution is to allow XState to run separately and communicate via message passing. For example, an actor in your system could **invoke** an XState machine as an external service (similar to invoking a promise or callback). XState v5 even supports the idea of an actor “system” and actor references by ID within its own context. However, this gets advanced – for most cases, wrapping the XState logic inside an actor is sufficient. The best practice is to **abstract away the differences** so that from a user’s perspective, an XState-based actor or a “plain” actor behave the same in your framework’s API.

## Migration-Friendly API Design Patterns

Transitioning an API from returning live actor instances to returning actor definitions (blueprints) is tricky, but there are patterns to ease the migration:

* **Dual API (Temporary):** Maintain two functions or modes – one that directly creates & starts an actor (for backwards compatibility), and the new one that returns an `ActorDefinition`. For example, you might introduce `ActorSystem.spawn(definition)` in v2 for the new workflow, but keep an easy helper like `ActorSystem.createActorAndStart(config)` (or an option in `createActor`) for the old workflow. This could internally do `const def = createActor(config); system.spawn(def)`, returning the `ActorPID`. The goal is to let existing code continue to work with minimal changes (perhaps just adding an import or an `await system.spawn(...)`). Over time, you can guide users to use the explicit spawn model. **Akka** took this approach when introducing Akka Typed – classic `actorOf(Props)` co-existed with the new typed `spawn(Behavior)` API, and interoperability was provided to gradually migrate. Similarly, you can provide an **adaptor layer**: e.g., mark the old `createActor()` (that returned an instance) as deprecated, but implement it by calling the new system under the hood.

* **Overloads & Conditional Types:** If you prefer a single entry-point function, TypeScript’s type system can differentiate based on input. For instance, you could overload `createActor` such that passing an `XStateActorConfig` returns an `ActorPID`, whereas passing a normal config returns an `ActorDefinition`. This uses function overload signatures or a generic conditional return type. TypeScript’s **conditional types** allow encoding such logic at compile time – a classic example is a `createLabel(x)` function that returns different types based on whether `x` is a string or number, which can be achieved with one implementation using conditional types instead of many overloads. In your case, the condition could be on a discriminant property in the config (e.g., `config.kind === 'xstate'`). This way, **type inference guides the developer**: if they call `createActor(myMachineConfig)`, TS knows it’s XState config and will treat the return type as a live actor with `send()` etc. (because that config type is tagged accordingly). Conversely, a standard behavior config would infer a return of `ActorDefinition`. This approach keeps a single function name, easing migration, but **requires careful documentation** – it can be confusing if not clearly communicated. Developers might not realize why their `createActor` sometimes yields an object with `.start()` and sometimes not, unless the types make it obvious.

* **Deprecation and Gradual Change:** No matter the approach, it’s wise to **support both patterns during a transition period**. For example, in version 2.x you could allow `createActor(config, {autoSpawn: true})` which returns an actor instance (spawning it immediately in a default system). This provides an **“escape hatch”** for the common case where the user just wants a quick actor (much like XState’s createActor). Over time, you could flip the default or remove this in v3 after users have migrated to explicitly using `ActorSystem.spawn`. Providing clear compile-time deprecation warnings (using JSDoc `@deprecated` or TS warnings) and migration guides is essential. The idea is to **“make the common case easy, and the advanced case possible”** – in line with your stated principle. So you might keep `createActor` as the easy one-step (spawning behind the scenes) and introduce a new `defineActor` or similar for advanced usage, *or vice versa*. Just avoid a situation where a ton of user code breaks overnight; give them a path to opt in to the new model gradually.

* **Example of Successful Transition:** Look at how XState itself handled their API evolution. In v4, one would do `const machine = createMachine(...); interpret(machine).start()`. In v5, they simplified it to `const actor = createActor(logic); actor.start()` as a unified API, effectively renaming interpret to createActor. They introduced this in a major version with thorough documentation. Another example: **Akka.NET** vs Akka (JVM) – Akka.NET stuck with the classic model, but Akka on JVM introduced a typed API where the concept of `Behavior` (actor definition) is front-and-center. They didn’t try to make one method do double duty; they provided a new set of APIs and allowed gradual adoption. This suggests that if the conceptual shift is large, a **clean break with parallel support** is often clearer than a single polymorphic method.

In summary, a migration-friendly design will likely **offer both the old and new patterns simultaneously**, clearly signpost the new preferred usage, and perhaps use TypeScript features to reduce friction. By prioritizing developer experience (DX), you ensure that developers can adopt the new definition-based approach at their own pace, all while new code can take advantage of the more structured API. Over time, you can deprecate the legacy usage once most consumers have switched.

## Type Safety Implications of a Polymorphic `createActor`

Having `createActor` return different types based on input config **can be made type-safe**, but it adds complexity. TypeScript does allow **function overloads** and **conditional return types** to model this. For example, you could write:

```ts
function createActor(config: XStateActorConfig): ActorPID;  
function createActor(config: BehaviorConfig): ActorDefinition;  
function createActor(config: AnyActorConfig): ActorPID | ActorDefinition { … }
```

Callers would then get an `ActorPID` if the argument is an `XStateActorConfig` (which might be discerned by a discriminant property or unique fields), otherwise an `ActorDefinition`. The compiler will resolve the correct overload signature when types are known. This provides compile-time safety – attempts to call `.send()` on an ActorDefinition would error, and conversely failing to start an XState-based actor would also be a mistake caught by types.

TypeScript’s **conditional types** offer an even more flexible way to do this with a single generic function. Using a pattern similar to the official docs’ `createLabel` example, you could define `createActor<T extends ActorConfig>(config: T): T extends XStateActorConfig ? ActorPID : ActorDefinition`. This means the return type is computed from the input type. When `T` is XState config, the return is `ActorPID`; when `T` is not, return is `ActorDefinition`. This can keep the API surface minimal (one function name) while preserving type safety.

**Pitfalls:** The downside is **maintainability and clarity**. Overloads and conditional types make the function signature more complex. New contributors (or users reading intellisense) might be confused why `createActor` sometimes yields one type vs another. There’s also the risk of unions: if the type of the config is not well-known (e.g., a generic itself or a union), TypeScript might infer a union return (ActorPID | ActorDefinition), forcing the user to narrow it. This can degrade the DX you’re trying so hard to improve. Also, writing and testing these type definitions is non-trivial – you need to ensure the TS compiler correctly narrows the type in various scenarios.

From a **performance** standpoint, there is no runtime cost to using overloads/conditional types – it’s all compile-time. So the concerns are really about API complexity. It may actually be **simpler to have two explicit functions** (say `defineActor` vs `spawnActor`, or an option like `immediate: true`) than to have one polymorphic function. The explicit approach might be more verbose, but it’s self-documenting: developers immediately know which they are getting by the function they call. On the other hand, a single `createActor` that does different things can be seen as *convenient magic* or *confusing*, depending on the user’s familiarity.

In summary, TypeScript *can* elegantly handle a polymorphic `createActor` using advanced types. Just be cautious: **the clever solution isn’t always the clearest**. Given your priority of **70% DX**, you might opt for a design that is slightly more verbose but obvious, rather than a hyper-generic API that could confuse. If you do implement polymorphism, document it clearly (e.g., in TSDoc, “if you pass an XState machine config, this function returns a started actor instance; otherwise it returns a definition to be spawned”). This ensures that the “magic” is discoverable and doesn’t violate the principle of least surprise for developers.

## Auto-Start vs. Deferred Start of Actors

**Immediate vs Explicit Start:** Different frameworks handle actor startup differently, often reflecting their use cases. In many backend actor systems, an actor is *automatically started as soon as it’s created/spawned*. For instance, Akka (and Akka.NET) will begin the actor’s lifecycle immediately upon `actorOf(...)` – “Actors are automatically started asynchronously when created.”. The returned `ActorRef` is live and ready to receive messages right away. Similarly, in Proto.Actor or Orleans, once you spawn or get a reference, you can send messages without an extra start step (Orleans activates on first message silently). The rationale is that on the server side, there’s rarely a need to delay actor startup after creation; doing it in one step reduces the chance of errors (like forgetting to start).

On the other hand, **XState** (geared towards front-end and workflow logic) uses a deferred start: you create an actor (which sets up the internal structures) but **must call `actor.start()`** to actually begin processing events. This pattern has a few benefits in that context: it allows you to set up event listeners or subscriptions *before* the actor does anything, ensuring you don’t miss its initial state or any events. It also gives you a moment to, say, configure or inject context before running. In UI scenarios, you might want to create an actor when a component initializes but only start it when the component is truly mounted, etc. The downside is, as you experienced, it’s easy for a user to call `createActor()` and then attempt `send()` immediately (forgetting to start), leading to runtime errors or no-ops. XState mitigates this by making it obvious in docs and by not processing events until started (possibly warning if not started).

**Auto-Start Option:** For your framework, you can consider an **`autoStart` flag or default behavior**. If developer ease is paramount, having `createActor` (in the unified instance-returning mode) automatically spawn and start the actor makes the API simpler – one call and done. This mirrors how frameworks like nact or Comedy work: `spawn()` returns an actor that’s running, and you can dispatch to it immediately. If you keep the definition approach, you might provide something like `system.spawn(def, { start: true })` or simply note that spawning inherently starts the actor. In most actor systems, spawning *is* starting – there isn’t a separate call to start after spawn (the actor’s `initialize` or constructor logic is invoked immediately). So aligning with that convention could reduce confusion.

However, if you find value in the XState-style two-phase (perhaps for consistency with XState integration), you could also allow a **manual start** for advanced cases. One pattern might be: `createActor` returns an ActorDefinition normally, but if user calls something like `ActorSystem.spawnImmediate(config)`, it both creates and starts it in one go, returning the instance. This gives power users flexibility (maybe they want to batch create a bunch of definitions and spawn them later on a specific node, etc.), while newcomers have a straightforward path.

**Lifecycle Management Best Practices:** Regardless of auto-start or not, clearly define how actors are stopped and what their lifecycle is. Many frameworks automatically tie an actor’s lifecycle to its parent or system:

* In Akka, if the parent stops, all children stop. There’s usually no concept of pausing an actor – it’s either running or stopped (except if you implement your own pause via behavior changes).
* In your framework, since v1 allowed explicit `actor.stop()`, continue to support graceful stops. If you introduce definitions, maybe also introduce a notion of an actor lifecycle policy (like if an actor is created via createActor but not spawned, is it just garbage collected or held for future use? Most likely it’s just a definition object with no resources, so that’s fine).

**Auto-Start in UI vs Backend:** It’s worth noting the context: front-end libraries (like XState, React actors, etc.) often opt for explicit start/stop to give the developer control over side effects (start might initiate HTTP calls, etc.). In a backend or system framework, auto-start is more common. Given that Actor-Web is about web applications but possibly on the server or a broader context, leaning to auto-start could improve DX (less ceremony). You could still take a cue from XState and allow attaching listeners before an actor truly starts processing. For example, if a user wants to monitor an actor’s events, they might do `const actor = createActor(...); actor.on('event', ...); actor.start()`. In your design, if auto-start is default, you can provide an API to subscribe to the actor *immediately* after spawn (perhaps the actor buffers events until the first listener is attached, etc., though that complicates things).

**Best Practice:** Many frameworks document clearly what the creation functions do. If you choose auto-start, document that “creating/spawning an actor will automatically begin its execution (there is no separate start call)”. If you choose deferred start for certain actors (maybe just for XState actors), ensure that is consistently handled. Perhaps XState-powered actors could be started immediately by the adapter unless the user explicitly wants control. Since your priority is **developer experience**, err on the side of not requiring extra steps unless they are absolutely necessary.

In summary, **immediate instantiation is the norm in many actor systems** for simplicity, whereas **deferred start is a niche feature** typically for UI/statechart scenarios. You can support both: make the default pattern simple (auto-start), and offer an advanced hook for those who need to manage the timing. Managing actor lifecycles then becomes mostly about when to call `stop()` (which should gracefully terminate the actor and its children). Follow the principle that an actor should be usable as soon as a developer “creates” it, unless there’s a compelling reason to make them call an extra method. By aligning with common patterns and clearly documenting exceptions (like XState integration nuances), you’ll provide a clean and intuitive API that still honors actor model fundamentals.

**Sources:**

* Akka (Scala/Java) and Akka.NET documentation on actor creation and references
* Orleans virtual actors overview (no explicit creation – virtual existence)
* Proto.Actor documentation (Props and Spawn pattern)
* XState v5 documentation (actors and actor logic creators, usage of `createActor`)
* Comedy.js README (Node actor framework example of creating and using actors)
* TypeScript Handbook – conditional types and function overload example
